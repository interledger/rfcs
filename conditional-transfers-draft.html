<!DOCTYPE html>
<html>
  <head>
    <title>Conditional Transactions</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "CG-DRAFT",
          shortName:  "conditional-transactions",
          authors: [{
              name:       "Stefan Thomas",
              url:        "https://justmoon.net/",
              company:    "Ripple Labs",
              companyURL: "https://www.ripplelabs.com/"
          }],
          editors: [{
              name: "Adrian Hope-Bailie",
              url: "https://medium.com/@ahopebailie/",
              company: "Ripple Labs",
              companyURL: "https://www.ripplelabs.com/"
          }],
          wg:           "Interledger Payments Community Group",
          wgURI:        "http://interledger.org/",
          wgPublicList: "public-interledger",
          localBiblio: {
            "ILP": {
              title: "A Protocol for Assured Interledger Payments",
              href: "https://interledger.org/protocol.pdf",
              authors: [
                "Stefan Thomas",
                "Evan Schwartz"
              ],
              status: "unofficial",
              publisher: "Ripple Labs"
            }
          }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        Many distributed systems use the the two-phase commit pattern to achieve atomicity of transactions. During the preparation phase the distributed participants must agree on the conditions under which a transaction should be committed and during the execution phase must make a processing decision about whether or not to commit the transaction (if the condition has been fulfilled).</p>
        <p>
            To achieve consensus on the execution condition and the fulfillment thereof, it is necessary to define a standard format for conditions to be expressed and shared between participants. This recommendation defines a standard format for the expression of cryptographically signed conditions and fulfillments.</p>
      </section>

    <section id='sotd'>
      <p><!-- Add additional "Status of This Document" notes here --></p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        Transactions within a centralised system are usually relatively safe, fast and cheap. However, executing transactions across a distributed set of participants across the Web are difficult, risky, slow and expensive if they are possible at all. Most of these problems stem from a lack of standardization among the systems that provide such transactions.
      </p>
      <p>
          Two phase commit is a pattern that provides security and robustness to distributed transactions. However, the transaction semantics and rules must be agreed upon and strictly enforced among participants in a distributed transaction.
      </p>
      <p>
        This document outlines the functionality that participants would have to provide and proposes a specific set of semantics for that functionality. Section <a href="#transaction-states"></a> explains the basic semantics of preparing a transaction and executing or rolling-back based on a condition. Section <a href="#condition-types"></a> provides a list of the most useful condition types that participants may support.
      </p>
      <p>
        Note that the <em>semantic meaning</em> of conditions must be enforced equally by all participants, while the <em>syntax</em> for expressing these conditions does not need to be the same. Transaction co-ordinators can convert between different syntax variations. In section <a href='#syntax'></a> we will provide a recommended syntax based on [[!JSON-LD]]. Section <a href="#syntax-example-bitcoin"></a> gives an example of how to convert it into an existing, but very different syntax.
      </p>
    </section>
    <section id="transaction-states">
      <h2>Transaction States</h2>
      <p>
        Distributed systems using two-phase commit MUST provide the ability to first prepare and then commit a transaction. A staged transaction MUST have a state where it can either be executed or cancelled based only on an execution and a cancellation condition respectively as outlined in this document. The semantics of the conditions are discussed in detail in section <a href="#condition-types"></a>.
      </p>
      <p>
        The possible states of a staged transaction are as follows:
      </p>
      <dl>
        <dt>proposed</dt>
        <dd>The initial state of a new transaction.</dd>
        <dt>prepared</dt>
        <dd>The state of a transaction that is ready to be either committed or rolled-back.</dd>
        <dt>executed</dt>
        <dd>The state of a transaction whose execution condition has been met and the transaction has been fully executed.</dd>
        <dt>cancelled</dt>
        <dd>The state of a transaction whose cancellation condition has been met and the transaction has been fully rolled-back.</dd>
      </dl>
      <p>
        The participants in a distributed system MAY enforce any rules and policies for when a transfer will transition to the <em>prepared</em> state. These policies or <em>preconditions</em> may include requirements resulting out of business, legal, compliance, risk or other considerations. When a policy is not met a participant MAY reject the transaction or wait for the policy to be met later.</p>
        <p>
            For example, a participant might require information on the purpose of a transaction for compliance reasons. Ledgers SHOULD clearly state their policies wherever possible.
      </p>
      <p>
        When transitioning a transaction to the <em>prepared</em> state, a participant MUST ensure that it can continue to guarantee that this transaction can be executed or cancelled.
      </p>
      <p>
        Once a transaction is <em>prepared</em> it MUST transition to <em>executed</em> if the execution condition is met and the cancellation condition is not met.
      </p>
      <p>
        Once a transaction is <em>prepared</em> it MUST transition to <em>cancelled</em> if the cancellation condition is met.
      </p>
    </section>

    <section id="syntax">
      <h2>Syntax</h2>

      <p>
        Conditions MAY be described using any syntax. This document introduces and uses a recommended syntax based on JSON.
      </p>

      <section id="syntax-converting">
        <h2>Converting between syntaxes</h2>

        <!-- TODO: Maybe should be in appendix? -->
        <section id="syntax-example-bitcoin">
          <h2>Example: Bitcoin scripts</h2>
        </section>
      </section>
    </section>

    <section id="conditions">
      <h2>Conditions</h2>
      <p>
        A condition is an object describing a statement which is either true or false. The fields of this object depend on the type of condition. The different types and their constituent fields are described in section <a href="#condition-types"></a>.
      </p>

      <pre class='example highlight'>
        {
          "type": "preimage-sha-2-256",
          "hash": "13550350a8681c84c861aac2e5b440161c2b33a3e4f302ac680ca5b686de48de"
        }
      </pre>
    </section>

    <section id="fulfillment">
      <h2>Fulfillment</h2>

      <p>
        Conditions may be fulfilled explicitly, by submitting a fulfillment object. Or they may be fulfilled implicitly depending on the condition.
      </p>

      <section id="fulfillment-explicit">
        <h2>Explicit fulfillment</h2>
        <p>
          Some conditions can be fulfilled explicitly by submitting a fulfillment object to the participants.
        </p>
        <p>
          Here is an example condition and corresponding fulfillment:
        </p>

        <pre class='example highlight'>
          // Condition
          {
            "@context": "https://interledger.org/schema/condition",
            "type": "preimage-sha-2-256",
            "hash": "13550350a8681c84c861aac2e5b440161c2b33a3e4f302ac680ca5b686de48de"
          }

          // Fulfillment
          {
            "@context": "https://interledger.org/schema/fulfillment",
            "type": "preimage-sha-2-256",
            "message": "ZXhhbXBsZQo="
          }
        </pre>
      </section>

      <section id="fulfillment-implicit">
        <h2>Implicit fulfillment</h2>

        <p>
          Some conditions, such as <a href="#condition-types-temporal"></a> can only be fulfilled implicitly.
        </p>
      </section>
    </section>

    <section id="condition-types">
      <h2>Condition Types</h2>
      <p>
        Participants MAY support a subset or a superset of the conditions described in this document. However, they MUST publicly indicate which conditions they support and if there are any limitations on these conditions. Some condition types are part of a minimal subset that compliant participants MUST support. See <a href="#condition-types-minimal-subset"></a>. In addition, condition types that are part of the minimal subset are introduced in their respective sections using the verb "MUST", whereas optional condition types are introduced using the verb "MAY".
      </p>
      <p>
        When a new transaction is proposed to a participants with an execution or cancellation condition that the participant does not support, the participant MUST reject the transaction.
      </p>
      <section>
        <h2>Cryptographic Conditions</h2>
        <p>
          Often, transactions are dependent on conditions that are external to the system on which the transaction is taking place. Since a participant can't perceive these conditions directly, it is provided with a cryptographic representation of the condition. Note that the meaning of a given condition may not be known to the participant and does not need to be.
        </p>
        <section>
          <h2>Signatures using asymmetric cryptography</h2>
          <p>
            An asymmetric cryptographic condition generally specifies some algorithm, a message to be signed and a public key that it needs to be signed with. The condition is fulfilled when a valid signature matching these inputs is provided.
            [[!HTTP-SIGNATURES]]
          </p>
          <section>
            <h2>RSA</h2>
          </section>
          <section>
            <h2>ECDSA</h2>
          </section>
          <section>
            <h2>Ed25519</h2>
          </section>
        </section>
        <section id="conditions-crypto-preimage">
          <h2>Hash preimage conditions</h2>
        </section>
      </section>

      <section>
        <h2>Boolean Conditions</h2>
        <p>
          It is a useful to be able to combine conditions. For example, in some cases it may be desirable to have a transaction whose execution depends not on one signature, but on two different signatures.
        </p>
        <section>
          <h2>AND</h2>
          <p>
            The <tt>and</tt> condition specifies an array of sub-conditions which MAY be of any of the types specified in this document. The <tt>and</tt> condition is true if all of its sub-conditions are true.
          </p>
        </section>
        <section>
          <h2>OR</h2>
          <p>
            The <tt>or</tt> condition specifies an array of sub-conditions which MAY be of any of the types specified in this document. The <tt>or</tt> condition is true if one or more of its sub-conditions are true.
          </p>
        </section>
        <section>
          <h2>Threshold gates</h2>
          <p>
            The <tt>threshold</tt> condition is a generalization of <tt>and</tt> and <tt>or</tt>. It specifies an array of <em>n</em> sub-conditions as well as a threshold <em>t</em> which MUST be less than or equal to <em>n</em>. The <tt>threshold</tt> condition is true if <em>t</em> of its sub-conditions are true. If <em>t = 1</em>, the <tt>threshold</tt> condition behaves the same as an <tt>or</tt> condition. If <em>t = n</em>, the threshold condition behaves the same as an <tt>and</tt> condition.
          </p>
        </section>
        <section>
          <h2>Weighted threshold gates</h2>
          <p>
            The <tt>weighted-threshold</tt> condition is similar to the <tt>threshold</tt> condition, except each sub-condition MAY optionally specify a weight <em>w</em>. If a sub-condition does not specify a weight, <em>w = 1</em> is assumed. The threshold <em>t</em> MUST be less than or equal to the sum of the weights. When counting the weights, each true condition counts for <em>w</em> and the <tt>weighted-threshold</tt> condition is true iff the sum of weights for true sub-conditions is greater than or equal to <em>t</em>.
          </p>
        </section>
        <section>
          <h2>NOT</h2>
          <p>Participants MAY offer conditions which guarantee that a participant has not seen a valid fulfillment of a given cryptographic condition.</p>
          <p>A <tt>not</tt> condition specifies a single sub-condition which MUST be a cryptographic condition.</p>
          <p>Participants who offer this type of condition MUST keep a record of every transactions and its conditions. In addition, they MUST record any valid fulfillment for a cryptographic condition if it fulfills a condition or subcondition of any transaction on record. Valid fulfillments for conditions that are not part of any transaction on record MAY be discarded.</p>
          <p>A <tt>not</tt> condition is true if the ledger has never recorded a fulfillment for the provided sub-condition.</p>
        </section>
      </section>

      <section id="condition-types-temporal">
        <h2>Temporal Conditions</h2>
        <p>
          Temporal conditions are conditions that are true or false based on an objective view of time. For the purposes of this document we use Universal Coordinated Time (UTC) expressed in [[!RFC3339]] format.
        </p>
        <section id="conditions-before-t">
          <h2>Before <em>t</em></h2>
          <p>
            The <tt>before</tt> condition is true if the current time is less than the provided timestamp.
          </p>
        </section>
        <section id="conditions-after-t">
          <h2>After <em>t</em></h2>
          <p>
            The <tt>after</tt> condition is true if the current time is greater than the provided timestamp.
          </p>
        </section>
      </section>

      <section id="conditions-minimal-subset">
        <h2>Minimal Subset</h2>
        <p>
          Participants MUST at least support the following conditions in the execution condition:
        </p>
        <ul>
          <li>SHA-2-256 hash preimage condition as described in <a href="#condition-types-crypto-preimage"></a></li>
        </ul>
        <p>
          Participants MUST at least support the following conditions in the cancellation condition to support transaction time-outs which are essential to the two phase commit pattern:
        </p>
        <ul>
          <li>After <em>t</em> condition as described in <a href="#condition-types-after-t"></a></li>
        </ul>
      </section>
    </section>
  </body>
</html>
