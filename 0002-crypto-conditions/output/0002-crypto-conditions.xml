<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.39 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3280 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3280.xml">
<!ENTITY RFC4055 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC6920 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6920.xml">
<!ENTITY RFC8017 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8017.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-08 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-08.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-02" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="A." surname="Hope-Bailie" fullname="Adrian Hope-Bailie">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>adrian@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2017" month="January" day="08"/>

    <area>security</area>
    
    

    <abstract>


<t>The crypto-conditions specification defines a set of encoding formats and data structures for <spanx style="strong">conditions</spanx> and <spanx style="strong">fulfillments</spanx>.  A condition uniquely identifies a logical "boolean circuit" constructed from one or more logic gates, evaluated by either validating a cryptographic signature or verifying the preimage of a hash digest. A fulfillment is a data structure encoding one or more cryptographic signatures and hash digest preimages that define the structure of the circuit and provide inputs to the logic gates allowing for the result of the circuit to be evaluated.</t>

<t>A fulfillment is validated by evaluating that the circuit output is TRUE but also that the provided fulfillment matches the circuit fingerprint, the condition.</t>

<t>Since evaluation of some of the logic gates in the circuit (those that are signatures) also take a message as input the evaluation of the entire fulfillment takes an optional input message which is passed to each logic gate as required. As such the algorithm to validate a fulfillment against a condition and a message matches that of other signature schemes and a crypto-condition can serve as a sophisticated and flexible replacement for a simple signature where the condition is used as the public key and the fulfillment as the signature.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Crypto-conditions is a scheme for composing signature-like structures from one or more existing signature scheme or hash digest primitives. It defines a mechanism for these existing primitives to be combined and grouped to create complex signature arrangements but still maintain the useful properties of a simple signature, most notably, that a deterministic algorithm exists to verify the signature against a message given a public key.</t>

<t>Using crypto-conditions, existing primitives such as RSA and ED25519 signature schemes and SHA256 digest algorithms can be used as logic gates to construct complex boolean circuits which can then be used as a compound signature. The validation function for these compound signatures takes as input the fingerprint of the circuit, called the condition, the circuit definition and minimum required logic gates with their inputs, called the fulfillment, and a message.</t>

<t>The function returns a boolean indicating if the compound signature is valid or not. This property of crypto-conditions means they can be used in most scenarios as a replacement for existing signature schemes which also take as input, a public key (the condition), a signature (the fulfillment), and a message and return a boolean result.</t>

</section>
<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

</section>
<section anchor="types" title="Types">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>The different types of crypto-conditions each have different internal strutures and employ different cryptographic algorithms as primitives.</t>

<section anchor="simple-and-compound-types" title="Simple and Compound Types">

<t>Two categories of crypto-condition type exist. Simple crypto-conditions provide a standard encoding of common cryptographic primitives with hardcoded parameters, e.g RSA and ED25519 signature or SHA256 hash digests. As such, simple types that use the same underlying scheme (e.g. SHA) with different parameters (e.g. 256 or 512 bits) are considered different crypto-condition types.</t>

<t>As an example, the types defined in this version of the specification all use the SHA-256 digest algorithm to generate the condition fingerprint. If a future version were to introduce SHA-512 as an alternative this would require that new types be defined for each existing type that must have its condition generated using SHA-512.</t>

<t>Compound crypto-conditions contain one or more sub-crypto-conditions. The compound crypto-condition will evaluate to TRUE or FALSE based on the output of the evaluation of the sub-crypto-conditions. In this way compound crypto-conditions are used to construct branches of a boolean circuit.</t>

<t>To validate a compound crypto-condition all sub-crypto-conditions are provided in the fulfillment so that the fingerprint of the compound condition can be generated. However, some of these sub-crypto-conditions may be sub-fulfillments and some may be sub-conditions, depending on the type and properties of the compound crypto-condition.</t>

<t>As an example, in the case of an m-of-n signature scheme, only m sub-fulfillments are needed to validate the compound signature, but the remaining n-m sub-conditions must still be provided to validate that the complete fulfillment matches the originally provided condition. This is an important feature for multi-party signing, when not all parties are ready to provide fulfillment yet all parties still desire fulfillment of the overall condition if enough counter-parties do provide fulfillment.</t>

</section>
<section anchor="defining-and-supporting-new-types" title="Defining and Supporting New types">

<t>The crypto-conditions format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>Implementations are not required to support all condition types therefore it is necessary to indicate which types an implementation must support in order to validate a fulfillment. For this reason, compound conditions are encoded with an additional field, subtypes, indicating the set of types and subtypes of all sub-crypto-conditions.</t>

</section>
</section>
<section anchor="features" title="Features">

<t>Crypto-conditions offer many of the features required of a regular signature scheme but also others which make them useful in a variety of new use cases.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">

<t>Each condition type uses one or more cryptographic primitives such as digest or signature algorithms. Compound types may contain sub-crypto-conditions of any type and indicate the set of underlying types in the subtypes field of the condition</t>

<t>To verify that a given implementation can verify a fulfillment for a given condition, implementations MUST ensure they are able to validate fulfillments of all types indicated in the subtypes field of a compound condition. If an implementation encounters an unknown type it MUST reject the condition as it will almost certainly be unable to validate the fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility. That said, it is important that implementations must inspect the ypes and subtypes of any crypto-conditions they encounter to ensure they do not pass on a condition they will not be able to verify at a later stage.</t>

<t>In many instances protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Wayne and Alf. Alf's condition can be a signature condition while Wayne's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Multi-level signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Mac, and Ped must approve; or Smithers must approve."</t>

</section>
<section anchor="crypto-conditions-as-a-signature-scheme" title="Crypto-conditions as a signature scheme">

<t>Crypto-conditions is a signature scheme for compound signatures which has similar properties to most other signature schemes, such as:</t>

<t><list style="numbers">
  <t>Validation of the signature (the fulfillment) is done using a public key (the condition) and a message as input</t>
  <t>The same public key can be used to validate multiple different signatures, each against a different message</t>
  <t>It is not possible to derive the signature from the public key</t>
</list></t>

<t>However, the scheme also has a number of features that make it unique such as:</t>

<t><list style="numbers">
  <t>It is possible to derive the same public key from any valid signature without the message</t>
  <t>It is possible for the same public key and message to be used to validate multiple signatures. For example, the fulfillment of an m-of-n condition will be different for each combination of n signatures.</t>
  <t>Composite signatures use one or more other signatures as components allowing for recursive signature validation logic to be defined.</t>
  <t>A valid signature can be produced using different combinations of private keys if the structure of the compound signature requires only specific combinations of internal signatures to be valid  (m of n signature scheme).</t>
</list></t>

</section>
<section anchor="crypto-conditions-as-a-trigger-in-distributed-systems" title="Crypto-conditions as a trigger in distributed systems">

<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time and resource-consuming aspects of the transaction are prepared by all participants following which a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consists of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>Crypto-conditions defines a mechanism for expressing these triggers as pairs of unique trigger identifiers (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>It is also important that all participants in such a distributed system are able to evaluate, prior to the trigger being fired, that they will be capable of verifying the trigger. Determinism is useless if validation of the trigger requires algorithms or resources that are not available to all participants.</t>

<t>Therefore conditions may be used as <spanx style="strong">distributable event descriptions</spanx> in the form of a <spanx style="emph">fingerprint</spanx>, but also <spanx style="emph">event meta-data</spanx> that allows the event verification system to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap size or memory) to verify the event notification later.</t>

<t>Fulfillments are therefore <spanx style="strong">cryptographically verifiable event notifications</spanx> that can be used to verify the event occurred but also that it matches the given description.</t>

<t>When using crypto-conditions as a trigger it will often make sense for the message that is used for validation to be empty to match the signature of the trigger processing system's API. This makes crypto-conditions compatible with systems that use simple hash-locks as triggers.</t>

<t>If a PKI signature scheme is being used for the triggers this would require a new key pair for each trigger which is impractical. Therefore the PREFIX compound type wraps a sub-crypto-condition with a message prefix that is applied to the message before signature validation. In this way a unique condition can be derived for each trigger even if the same key pair is re-used with an empty message.</t>

</section>
<section anchor="smart-signatures" title="Smart signatures">

<t>In the Interledger protocol, fulfillments provide non-repudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchronizes multiple transfers on distinct ledgers in an almost atomic end-to-end transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying cryptographic primitives are correctly implemented.</t>

</section>
</section>
<section anchor="validation-of-a-fulfillment" title="Validation of a fulfillment">

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, follows these steps:</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>If the fulfillment is a simple crypto-condition AND is based upon a signature scheme (such as RSA-PSS or ED25519) then any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M) (which may be empty).</t>
  <t>If the fulfillment is a compound crypto-condition then the sub-fulfillments MUST each be validated. In the case of the PREFIX-SHA-256 type the sub-fulfillment MUST be valid for F to be valid and in the case of the THRESHOLD-SHA-256 type the number of valid sub-fulfillments must be equal or greater than the threshold defined in F.</t>
</list></t>

<t>If the derived condition (D) matches the input condition (C) AND the boolean circuit defined by the fulfillment evaluates to TRUE then the fulfillment (F) fulfills the condition (C).</t>

<t>A more detailed validation algorithm for each crypto-condition type is provided with the details of the type later in this document. In each case the notation F.x or C.y implies; the decoded value of the field named x of the fulfillment and the decoded value of the field named y of the Condition respectively.</t>

<section anchor="subfulfillments" title="Subfulfillments">

<t>In validating a fulfillment for a compound crypto-condition it is necessary to validate one or more sub-fulfillments per step 3 above. In this instance the condition for one or more of these sub-fulfillments is often not available for comparison with the derived condition. Implementations MUST skip the first fulfillment validation step as defined above and only perform steps 2 and 3 of the validation.</t>

<t>The message (M) used to validate sub-fulfillments is the same message (M) used to validate F however in the case of the PREFIX-SHA-256 type this is prefixed with F.prefix before validation of the sub-fulfillment is performed.</t>

</section>
</section>
<section anchor="deriving-the-condition" title="Deriving the Condition">

<t>Since conditions provide a unique fingerprint for fulfillments it is important that a determinisitic algorithm is used to derive a condition. For each crypto-condition type details are provided on how to:</t>

<t><list style="numbers">
  <t>Assemble the fingerprint content and calculate the hash digest of this data.</t>
  <t>Calculate the maximum cost of validating a fulfillment</t>
</list></t>

<t>For compound types the fingerprint content will contain the complete, encoded, condition for all sub-crypto-conditions. Implementations MUST abide by the ordering rules provided when assembling the fingerprint content.</t>

<t>When calculating the fingerprint of a compound crypto-condition implementations MUST first derive the condition for all sub-fulfillments and include these conditions when assembling the fingerprint content.</t>

<section anchor="conditions-as-public-keys" title="Conditions as Public Keys">

<t>Since the condition is just a fingerprint and meta-data about the crypto-condition it can be transmitted freely in the same way a public key is shared publicly. It's not possible to derive the fulfillment from the condition.</t>

</section>
</section>
<section anchor="format" title="Format">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>.</t>

<section anchor="encoding-rules" title="Encoding Rules">

<t>Implementations of this specificiation MUST support encoding and decoding using Distinguished Encoding Rules (DER) as defined in <xref target="itu.X690.2015"></xref>. This is the canonical encoding format.</t>

<t>Alternative encodings may be used to represent top-level conditions and fulfillments but to ensure a determinisitic outcome in producing the condition fingerprint content, including any sub-conditions, MUST be DER encoded prior to hashing.</t>

<t>The exception is the PREIMAGE-SHA-256 condition where the fingerprint content is the raw preimage which is not encoded prior to hashing. This is to allow a PREIMAGE-SHA-256 crypto-condition to be used in systems where "hash-locks" are already in use.</t>

</section>
<section anchor="condition-format" title="Condition">

<t>The binary encoding of conditions differs based on their type. All types define at least a fingerprint and cost sub-field. Some types, such as the compound condition types, define additional sub-fields that are required to convey essential properties of the crypto-condition (such as the sub-types used by sub-conditions in the case of the compound types).</t>

<t>Each crypto-condition type has a type ID. The list of known types is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<t>Conditions are encoded as follows:</t>

<figure><artwork><![CDATA[
Condition ::= CHOICE {
  preimageSha256   [0] SimpleSha256Condition,
  prefixSha256     [1] CompoundSha256Condition,
  thresholdSha256  [2] CompoundSha256Condition,
  rsaSha256        [3] SimpleSha256Condition,
  ed25519Sha256    [4] SimpleSha256Condition
}

SimpleSha256Condition ::= SEQUENCE {
  fingerprint          OCTET STRING (SIZE(32)),
  cost                 INTEGER (0..4294967295)
}

CompoundSha256Condition ::= SEQUENCE {
  fingerprint          OCTET STRING (SIZE(32)),
  cost                 INTEGER (0..4294967295),
  subtypes             ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256   (0),
  prefixSha256     (1),
  thresholdSha256  (2),
  rsaSha256        (3),
  ed25519Sha256    (4)
}
]]></artwork></figure>

<section anchor="fingerprint" title="Fingerprint">

<t>The fingerprint is an octet string uniquely representing the condition with respect to other conditions <spanx style="strong">of the same type</spanx>.</t>

<t>Implementations which index conditions MUST use the complete encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint.</t>

<t>For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key.</t>

<t>For types that use PKI signature schemes, the signature is intentionally not included in the content that is used to compose the fingerprint. This means the fingerprint can be calculated without needing to know the message or having access to the private key.</t>

<t>Future types may use different functions to produce the fingerprint, which may have different lengths, therefore the field is encoded as a variable length string.</t>

</section>
<section anchor="cost" title="Cost">

<t>For each type, a cost function is defined which produces a determinsitic cost value based on the properties of the condition.</t>

<t>The cost functions are designed to produce a number that will increase rapidly if the structure and properties of a crypto-condition are such that they increase the resource requirements of a system that must validate the fulfillment.</t>

<t>The constants used in the cost functions are selected in order to provide some consistency across types for the cost value and the expected "real cost" of validation. This is not an exact science given that some validations will require signature verification (such as RSA and ED25519) and others will simply require hashing and storage of large values therefore the cost functions are roughly configured (through selection of constants) to be the number of bytes that would need to be processed by the SHA-256 hash digest algorithm to produce the equivalent amount of work.</t>

<t>The goal is to produce an indicative number that implementations can use to protect themselves from attacks involving crypto-conditions that would require massive resources to validate (denial of service type attacks).</t>

<t>Since dynamic heuristic measures can't be used to acheive this a deterministic value is required that can be produced consistently by any implementation, therefore for each crypto-condition type, an algorithm is provided for consistently calculating the cost.</t>

<t>Implementations MUST determine a safe cost ceiling based on the expected cost value of crypto-conditions they will need to process. When a crypto-condition is submitted to an implementation, the implementation MUST verify that it will be able to process a fulfillment with the given cost (i.e. the cost is lower than the allowed ceiling) and reject it if not.</t>

<t>Cost function constants have been rounded to numbers that have an efficient base-2 representation to facilitate efficient arithmetic operations.</t>

</section>
<section anchor="subtypes" title="Subtypes">

<t>Subtypes is a bitmap that indicates the set of types an implementation must support in order to be able to successfully validate the fulfillment of this condition. This is the set of types and subtypes of all sub-crypto-conditions, recursively excluding the type of the root crypto-condition.</t>

<t>It must be possible to verify that all types used in a crypto-condition are supported (including the types and subtypes of any sub-crypto-conditions) even if the fulfillment is not available to be analysed yet. Therefore, all compound conditions set the bits in this bitmap that correspond to the set of types and subtypes of all sub-crypto-conditions.</t>

<t>The field is encoded as a variable length BIT STRING, as defined in ASN.1, to accommodate new types that may be defined.</t>

<t>Each bit in the bitmap represents a type from the list of known types in the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type.</t>

<t>The presence of one or more sub-crypto-conditions of a specific type is indicated by setting the numbered bit corresponding to the type ID of that type.</t>

<t>In DER encoding, the bits in a bitstring are numbered from the MOST significant bit (bit 0) to least significant (bit 7) of the first byte and then continue with the MOST significant bit (bit 8) of the next byte, and so on. For example, a compound condition that contains an ED25519-SHA-256 crypto-condition as a sub-crypto-condition will set the bit at position 4 and the BITSTRING will be DER encoded with an appropriate tag byte followed by the three bytes 0x02 0x03 and 0x80, where 0x02 indicates the length (2 bytes, the first being the padding indicator), 0x03 indicates that there are 3 padding bits in the last byte and 0x80 indicates the 5 bits in the string are set to 00001.</t>

</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">

<t>The ASN.1 definition for fulfillments is defined as follows:</t>

<figure><artwork><![CDATA[
Fulfillment ::= CHOICE {
  preimageSha256   [0] PreimageFulfillment ,
  prefixSha256     [1] PrefixFulfillment,
  thresholdSha256  [2] ThresholdFulfillment,
  rsaSha256        [3] RsaSha256Fulfillment,
  ed25519Sha256    [4] Ed25519Sha512Fulfillment
}

PreimageFulfillment ::= SEQUENCE {
  preimage             OCTET STRING
}

PrefixFulfillment ::= SEQUENCE {
  prefix               OCTET STRING,
  maxMessageLength     INTEGER (0..4294967295),
  subfulfillment       Fulfillment
}

ThresholdFulfillment ::= SEQUENCE {
  subfulfillments      SET OF Fulfillment,
  subconditions        SET OF Condition
}

RsaSha256Fulfillment ::= SEQUENCE {
  modulus              OCTET STRING,
  signature            OCTET STRING
}

Ed25519Sha512Fulfillment ::= SEQUENCE {
  publicKey            OCTET STRING (SIZE(32)),
  signature            OCTET STRING (SIZE(64))
}
]]></artwork></figure>

</section>
</section>
<section anchor="crypto-condition-types" title="Crypto-Condition Types">
<t>The following condition types are defined in this version of the specification. While support for additional crypto-condition types may be added in the future and will be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>, no other types are supported by this specification.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">

<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the availability of the SHA-256 digest algorithm.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment as the validation of this crypto-condition type only requires that the SHA-256 digest of the preimage, taken from the fulfillment, matches the fingerprint, taken from the condition.</t>

<section anchor="preimage-sha-256-condition-type-maxcost" title="Cost">

<t>The cost is the size, in bytes, of the <spanx style="strong">unencoded</spanx> preimage.</t>

<figure><artwork><![CDATA[
cost = preimage length
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
-- The PREIMAGE-SHA-256 condition fingerprint content is not DER encoded
-- The fingerprint content is the preimage

-- Fulfillment 
PreimageFulfillment ::= SEQUENCE {
  preimage             OCTET STRING
}
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the <spanx style="strong">unencoded</spanx> preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment simply contains the preimage (encoded into a SEQUENCE of one element for consistency).</t>

</section>
<section anchor="preimage-sha-256-condition-type-validating" title="Validating">

<t>A PREIMAGE-SHA-256 fulfillment is valid iff C.fingerprint is equal to the SHA-256 hash digest of F.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<figure><artwork><![CDATA[
examplePreimageCondition Condition ::= 
  preimageSha256 : {
    fingerprint '7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069'H,
    cost         12
  }

examplePreimageFulfillment Fulfillment ::= 
  preimageSha256 : { 
    preimage '48656C6C 6F20576F 726C6421'H 
  }
]]></artwork></figure>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by its sub-crypto-condition as it is a compound crypto-condition type.</t>

<t>Prefix crypto-conditions provide a way to narrow the scope of other crypto-conditions that are used inside the prefix crypto-condition as a sub-crypto-condition.</t>

<t>Because a condition is the fingerprint of a public key, by creating a prefix crypto-condition that wraps another crypto-condition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>We can also use the prefix condition in contexts where there is an empty message used for validation of the fulfillment so that we can reuse the same key pair for multiple crypto-conditions, each with a different prefix, and therefore generate a unique condition and fulfillment each time.</t>

<t>Implementations MUST prepend the prefix to the provided message and will use the resulting value as the message to validate the sub-fulfillment.</t>

<section anchor="prefix-sha-256-condition-type-cost" title="Cost">

<t>The cost is the size, in bytes, of the <spanx style="strong">unencoded</spanx> prefix, plus the maximum message that will be accepted to be prefixed and validated by the subcondition, plus the cost of the sub-condition, plus the constant 1024.</t>

<figure><artwork><![CDATA[
cost = prefix.length (in bytes) + max_message_length + subcondition_cost + 1024
]]></artwork></figure>

</section>
<section anchor="prefix-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
PrefixFingerprintContents ::= SEQUENCE {
  prefix               OCTET STRING,
  maxMessageLength     INTEGER (0..4294967295),
  subcondition         Condition
}

-- Fulfillment 
PrefixFulfillment ::= SEQUENCE {
  prefix               OCTET STRING,
  maxMessageLength     INTEGER (0..4294967295),
  subfulfillment       Fulfillment
}
]]></artwork></figure>

</section>
<section anchor="prefix-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents which are a SEQUENCE of:</t>

<t><list style="hanging">
  <t hangText='prefix'>
  An arbitrary octet string which will be prepended to the message during validation of the sub-fulfillment.</t>
  <t hangText='maxMessageLength'>
  The maximum size, in bytes, of the message that will be accepted during validation of the fulfillment of this condition.</t>
  <t hangText='subcondition'>
  The condition derived from the sub-fulfillment of this crypto-condition.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment of a PREFIX-SHA-256 crypto-condition is a PrefixFulfillment which is a SEQUENCE of:</t>

<t><list style="hanging">
  <t hangText='prefix'>
  An arbitrary octet string which will be prepended to the message during validation of the sub-fulfillment.</t>
  <t hangText='maxMessageLength'>
  The maximum size, in bytes, of the message that will be accepted during validation of the fulfillment of this condition.</t>
  <t hangText='subfulfillment'>
  A fulfillment that will be verified against the prefixed message.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-validating" title="Validating">

<t>A PREFIX-SHA-256 fulfillment is valid iff:</t>

<t><list style="numbers">
  <t>The size of M, in bytes, is less than or equal to F.maxMessageLength AND</t>
  <t>F.subfulfillment is valid, where the message used for validation of f is M prefixed by F.prefix AND</t>
  <t>D is equal to C</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<figure><artwork><![CDATA[
examplePrefixCondition Condition ::=
  prefixSha256 : {
    fingerprint 'BB1AC526 0C0141B7 E54B26EC 2330637C 5597BF81 1951AC09 E744AD20 FF77E287'H,
    cost         1024,
    subtypes    { preimageSha256 }
  }

examplePrefixFulfillment Fulfillment ::= 
  prefixSha256 : {
    prefix           ''H,
    maxMessageLength  0,
    subfulfillment    preimageSha256 : { preimage ''H }
  }

examplePrefixFingerprintContents PrefixFingerprintContents ::= {
  prefix           ''H,
  maxMessageLength  0,
  subcondition      preimageSha256 : {
    fingerprint      'E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855'H,
    cost              0
  }
}
]]></artwork></figure>

<t>Note that the example given, while useful to demonstrate the structure, has less practical security value that the use of an RSA-SHA-256 or ED25519-SHA-256 subfulfillment. Since the subfulfillment is a PREIMAGE-SHA-256, the validation of which ignores the incoming message, as long as the prefix, maxMessagelength and preimage provided in the subfulfillment are correct, the parent PREFIX-SHA-256 fulfillment will validate.</t>

<t>In this case, wrapping the PREIMAGE-SHA-256 crypto-condition in the PREFIX-SHA-256 crypto-condition, has the effect of enforcing a message length of 0 bytes.</t>

<t>Note also, any change to the PREFIX-SHA-256 crypto-condition's prefix and maxMessageLength values result in a different fingerprint value, effectively namespacing the underlying preimage and re-hashing it. The result is a new crypto-condition with a new and unique fingerprint with no change to the underlying sub-crypto-condition.</t>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by any of its sub-crypto-conditions as it is a compound crypto-condition type.</t>

<section anchor="threshold-sha-256-condition-type-cost" title="Cost">

<t>The cost is the sum of the F.threshold largest cost values of all sub-conditions, added to 1024 times the total number of sub-conditions.</t>

<figure><artwork><![CDATA[
cost = (sum of largest F.threshold subcondition.cost values) + 1024 * F.subconditions.count
]]></artwork></figure>

<t>For example, if a threshold crypto-condition contains 5 sub-conditions with costs of 64, 64, 82, 84 and 84 and has a threshold of 3, the cost is equal to the sum of the largest three sub-condition costs (82 + 84 + 84 = 250) plus 1024 times the number of sub-conditions (1024 * 5 = 5120): 5370</t>

</section>
<section anchor="threshold-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
ThresholdFingerprintContents ::= SEQUENCE {
  threshold            INTEGER (1..65535),
  subconditions        SET OF Condition
}

-- Fulfillment 
ThresholdFulfillment ::= SEQUENCE {
  subfulfillments      SET OF Fulfillment,
  subconditions        SET OF Condition
}
]]></artwork></figure>

</section>
<section anchor="threshold-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents which are a SEQUENCE of:</t>

<t><list style="hanging">
  <t hangText='threshold'>
  A number that MUST be an integer in the range 1 â€¦ 65535. In order to fulfill a threshold condition, the count of the sub-fulfillments MUST be equal to the threshold.</t>
  <t hangText='subconditions'>
  The set of sub-conditions, F.threshold of which MUST be satisfied by valid sub-fulfillments provided in the fulfillment. The SET of DER encoded sub-conditions is sorted according to the DER encoding rules for a SET, in lexicographic (big-endian) order, smallest first as defined in section 11.6 of <xref target="itu.X690.2015"></xref>.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment of a THRESHOLD-SHA-256 crypto-condition is a ThresholdFulfillment which is a SEQUENCE of:</t>

<t><list style="hanging">
  <t hangText='subfulfillments'>
  A SET OF fulfillments. The number of elements in this set is equal to the threshold therefore implementations must use the length of this SET as the threshold value when deriving the fingerprint of this crypto-condition.</t>
  <t hangText='subconditions'>
  A SET OF conditions. This is the list of unfulfilled sub-conditions. This list must be combined with the list of conditions derived from the subfulfillments and the combined list, sorted, and used as the subconditions value when deriving the fingerprint of this crypto-condition.</t>
  <t>This may be an empty list.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-validating" title="Validating">

<t>A THRESHOLD-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>All F.subfulfillments are valid.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<figure><artwork><![CDATA[
exampleThresholdCondition Condition ::=
  thresholdSha256 : {
    fingerprint 'B4B84136 DF48A71D 73F4985C 04C6767A 778ECB65 BA7023B4 506823BE EE7631B9'H,
    cost         1024,
    subtypes    { preimageSha256 }
  }

exampleThresholdFulfillment Fulfillment ::=
  thresholdSha256 : {
    subfulfillments { preimageSha256 : { preimage ''H } },
    subconditions   { }
  }

exampleThresholdFingerprintContents ThresholdFingerprintContents ::= {
  threshold 1,
  subconditions {
    preimageSha256 : {
      fingerprint 'E3B0C442 98FC1C14 9AFBF4C8 996FB924 27AE41E4 649B934C A495991B 7852B855'H,
      cost         0
    }
  }
}

exampleThresholdCondition2 Condition ::=
  thresholdSha256 : {
    fingerprint '5A218ECE 7AC4BC77 157F04CB 4BC8DFCD 5C9D225A 55BD0AA7 60BCA2A4 F1773DC6'H,
    cost         2060,
    subtypes    { preimageSha256 }
  }

exampleThresholdFulfillment2 Fulfillment ::=
  thresholdSha256 : {
    subfulfillments { preimageSha256 : { preimage ''H } },
    subconditions {
      preimageSha256 : { 
        fingerprint '7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069'H,
        cost         12
      }
    }
  }

exampleThresholdFingerprintContents2 ThresholdFingerprintContents ::= {
  threshold 1,
  subconditions {
    preimageSha256 : {
      fingerprint 'E3B0C442 98FC1C14 9AFBF4C8 996FB924 27AE41E4 649B934C A495991B 7852B855'H,
      cost         0
    },
    preimageSha256 : {
      fingerprint '7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069'H,
      cost         12
    }
  }
}
]]></artwork></figure>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256 digest algorithm and the RSA-PSS signature scheme.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC8017"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefore, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC8017"></xref>. The algorithm parameters to use, as defined in <xref target="RFC4055"></xref> are:</t>

<figure><artwork><![CDATA[
pkcs-1 OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }

id-sha256 OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }

sha256Identifier AlgorithmIdentifier  ::=  {
  algorithm            id-sha256,
  parameters           nullParameters  
}
                          
id-mgf1 OBJECT IDENTIFIER  ::=  { pkcs-1 8 }                          
                          
mgf1SHA256Identifier AlgorithmIdentifier  ::=  {
  algorithm            id-mgf1,
  parameters           sha256Identifier 
}

rSASSA-PSS-SHA256-Params RSASSA-PSS-params ::=  {
  hashAlgorithm        sha256Identifier,
  maskGenAlgorithm     mgf1SHA256Identifier,
  saltLength           20,
  trailerField         1
}
]]></artwork></figure>

<section anchor="rsa-keys" title="RSA Keys">

<t>To optimize the RsaFulfillment, and enforce a public exponent value of 65537, only the RSA Public Key modulus is stored in the RsaFingerprintContents and RsaFulfillment.</t>

<t>The modulus is stored as an OCTET STRING representing an unsigned integer (i.e. no sign byte) in big-endian byte-order, the most significant byte being the first in the string.</t>

<t>Implementations MUST use moduli greater than 128 bytes (1017 bits) and smaller than or equal to 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref>. OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref>.</t>

<t>Implementations MUST use the value 65537 for the public exponent e as recommended in <xref target="RFC4871"></xref>. Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref>.</t>

<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref>. In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-condition-type-cost" title="Cost">

<t>The cost is the square of the RSA key modulus size (in bytes).</t>

<figure><artwork><![CDATA[
cost = (modulus size in bytes) ^ 2 
]]></artwork></figure>

</section>
<section anchor="rsa-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
RsaFingerprintContents ::= SEQUENCE {
  modulus              OCTET STRING
}

-- Fulfillment 
RsaSha256Fulfillment ::= SEQUENCE {
  modulus              OCTET STRING,
  signature            OCTET STRING
}
]]></artwork></figure>

</section>
<section anchor="rsa-sha-256-condition-type-condition" title="Condition Format">
<t>The fingerprint of an RSA-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents which is a SEQUENCE of a single element, the modulus of the RSA Key Pair.</t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment of an RSA-SHA-256 crypto-condition is an RsaSha256Fulfillment which is a SEQUENCE of:</t>

<t><list style="hanging">
  <t hangText='modulus'>
  The modulus of the RSA key pair used to sign and verify the signature provided.</t>
  <t hangText='signature'>
  An octet string representing the RSA signature on the message M.</t>
  <t>Implementations MUST verify that the signature is numerically less than the modulus.</t>
</list></t>

<t>Note that the message that has been signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-validating" title="Validating">

<t>An RSA-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, using the RSA public key with modulus = F.modulus and exponent = 65537 for verification.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<figure><artwork><![CDATA[
exampleRsaCondition Condition ::=
  rsaSha256 : {
    fingerprint 'B31FA820 6E4EA7E5 15337B3B 33082B87 76518010 85ED84FB 4DAEB247 BF698D7F'H,
    cost         65536
  }

exampleRsaSha256Fulfillment Fulfillment ::=
  rsaSha256 : {
    modulus   'E1EF8B24 D6F76B09 C81ED775 2AA262F0 44F04A87 4D43809D 31CEA612 F99B0C97 A8B43741 
               53E3EEF3 D6661684 3E0E41C2 93264B71 B6173DB1 CF0D6CD5 58C58657 706FCF09 7F704C48 
               3E59CBFD FD5B3EE7 BC80D740 C5E0F047 F3E85FC0 D7581577 6A6F3F23 C5DC5E79 7139A688 
               2E38336A 4A5FB361 37620FF3 663DBAE3 28472801 862F72F2 F87B202B 9C89ADD7 CD5B0A07 
               6F7C53E3 5039F67E D17EC815 E5B4305C C6319706 8D5E6E57 9BA6DE5F 4E3E57DF 5E4E072F 
               F2CE4C66 EB452339 73875275 9639F025 7BF57DBD 5C443FB5 158CCE0A 3D36ADC7 BA01F33A 
               0BB6DBB2 BF989D60 7112F234 4D993E77 E563C1D3 61DEDF57 DA96EF2C FC685F00 2B638246
               A5B309B9'H,
    signature '48E8945E FE007556 D5BF4D5F 249E4808 F7307E29 511D3262 DAEF61D8 8098F9AA 4A8BC062 
               3A8C9757 38F65D6B F459D543 F289D73C BC7AF4EA 3A33FBF3 EC444044 7911D722 94091E56 
               1833628E 49A772ED 608DE6C4 4595A91E 3E17D6CF 5EC3B252 8D63D2AD D6463989 B12EEC57 
               7DF64709 60DF6832 A9D84C36 0D1C217A D64C8625 BDB594FB 0ADA086C DECBBDE5 80D424BF 
               9746D2F0 C312826D BBB00AD6 8B52C4CB 7D47156B A35E3A98 1C973863 792CC80D 04A18021 
               0A524158 65B64B3A 61774B1D 3975D78A 98B0821E E55CA0F8 6305D425 29E10EB0 15CEFD40 
               2FB59B2A BB8DEEE5 2A6F2447 D2284603 D219CD4E 8CF9CFFD D5498889 C3780B59 DD6A57EF 
               7D732620'H
  }

exampleRsaFingerprintContents RsaFingerprintContents ::= {
  modulus     'E1EF8B24 D6F76B09 C81ED775 2AA262F0 44F04A87 4D43809D 31CEA612 F99B0C97 A8B43741 
               53E3EEF3 D6661684 3E0E41C2 93264B71 B6173DB1 CF0D6CD5 58C58657 706FCF09 7F704C48 
               3E59CBFD FD5B3EE7 BC80D740 C5E0F047 F3E85FC0 D7581577 6A6F3F23 C5DC5E79 7139A688 
               2E38336A 4A5FB361 37620FF3 663DBAE3 28472801 862F72F2 F87B202B 9C89ADD7 CD5B0A07 
               6F7C53E3 5039F67E D17EC815 E5B4305C C6319706 8D5E6E57 9BA6DE5F 4E3E57DF 5E4E072F 
               F2CE4C66 EB452339 73875275 9639F025 7BF57DBD 5C443FB5 158CCE0A 3D36ADC7 BA01F33A 
               0BB6DBB2 BF989D60 7112F234 4D993E77 E563C1D3 61DEDF57 DA96EF2C FC685F00 2B638246
               A5B309B9'H
}
]]></artwork></figure>

</section>
</section>
<section anchor="ed25519-sha-256-condition-type" title="ED25519-SHA256">
<t>ED25519-SHA-256 is assigned the type ID 4. It relies on the SHA-256 and SHA-512 digest algorithms and the ED25519 signature scheme.</t>

<t>The exact algorithm and encodings used for the public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function for this signature scheme.</t>

<section anchor="ed25519-sha-256-condition-type-cost" title="Cost">

<t>The public key and signature are a fixed size therefore the cost for an ED25519 crypto-condition is fixed at 131072.</t>

<figure><artwork><![CDATA[
cost = 131072
]]></artwork></figure>

</section>
<section anchor="ed25519-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
Ed25519Sha512Fulfillment ::= SEQUENCE {
  publicKey            OCTET STRING (SIZE(32)),
  signature            OCTET STRING (SIZE(64))
}

-- Fulfillment 
Ed25519FingerprintContents ::= SEQUENCE {
  publicKey            OCTET STRING (SIZE(32))
}
]]></artwork></figure>

</section>
<section anchor="ed25519-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of an ED25519-SHA-256 condition is the SHA-256 digest of the DER encoded Ed25519 public key included as the only value within a SEQUENCE. While the public key is already very small and constant size, we wrap it in a SEQUENCE type and hash it for consistency with the other types.</t>

</section>
<section anchor="ed25519-sha-256-condition-type-fulfillment" title="Fulfillment">

<t>The fulfillment of an ED25519-SHA-256 crypto-condition is an Ed25519Sha512Fulfillment which is a SEQUENCE of:</t>

<t><list style="hanging">
  <t hangText='publicKey'>
  An octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  An octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="ed25519-sha-256-condition-type-validating" title="Validating">

<t>An ED25519-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the ED25519 public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="example" title="Example">

<figure><artwork><![CDATA[
exampleEd25519Condition Condition ::=
  ed25519Sha256 : {
    fingerprint '799239AB A8FC4FF7 EABFBC4C 44E69E8B DFED9933 24E12ED6 4792ABE2 89CF1D5F'H,
    cost 131072
  }

exampleEd25519Fulfillment Fulfillment ::=
  ed25519Sha256 : {
    publicKey  'D75A9801 82B10AB7 D54BFED3 C964073A 0EE172F3 DAA62325 AF021A68 F707511A'H,
    signature  'E5564300 C360AC72 9086E2CC 806E828A 84877F1E B8E5D974 D873E065 22490155 
                5FB88215 90A33BAC C61E3970 1CF9B46B D25BF5F0 595BBE24 65514143 8E7A100B'H
  }

exampleEd25519FingerprintContents Ed25519FingerprintContents ::= {
  publicKey    'D75A9801 82B10AB7 D54BFED3 C964073A 0EE172F3 DAA62325 AF021A68 F707511A'H
}
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="uri-encoding-rules" title="URI Encoding Rules">

<t>Conditions can be encoded as URIs per the rules defined in the Named Information specification, <xref target="RFC6920"></xref>. There are no URI encoding rules for fulfillments.</t>

<t>Applications that require a string encoding for fulfillments MUST use an appropriate string encoding of the DER encoded binary representation of the fulfillment. No string encoding is defined in this specification. For consistency with the URI encoding of conditions, BASE64URL is recommended as described in <xref target="RFC4648"></xref>, Section 5.</t>

<t>The URI encoding is only used to encode top-level conditions and never for sub-conditions. The binary encoding is considered the canonical encoding.</t>

<section anchor="string-condition-format" title="Condition URI Format">

<t>Conditions are represented as URIs using the rules defined in <xref target="RFC6920"></xref> where the object being hashed is the DER encoded fingerprint content of the condition as described for the specific condition type.</t>

<t>While <xref target="RFC6920"></xref> allows for truncated hashes, implementations using the Named Information URI schemes for crypto-conditions MUST only use untruncated SHA-256 hashes (Hash Name: sha-256, ID: 1 from the "Named Information Hash Algorithm Registry" defined in <xref target="RFC6920"></xref>).</t>

</section>
<section anchor="new-uri-parameter-definitions" title="New URI Parameter Definitions">

<t><xref target="RFC6920"></xref> established the IANA registry of "Named Information URI Parameter Definitions". This specification defines three new definitions that are added to that registry and passed in URI encoded conditions as query string parameters.</t>

<section anchor="parameter-fingerprint-type-fpt" title="Parameter: Fingerprint Type (fpt)">

<t>The type parameter indicates the type of condition that is represented by the URI. The value MUST be one of the names from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

</section>
<section anchor="parameter-cost-cost" title="Parameter: Cost (cost)">

<t>The cost parameter is the cost of the condition that is represented by the URI.</t>

</section>
<section anchor="parameter-subtypes-subtypes" title="Parameter: Subtypes (subtypes)">

<t>The subtypes parameter indicates the types of conditions that are subtypes of the condition represented by the URI. The value MUST be a comma seperated list of names from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and SHOULD not include the type of the root crypto-condition. i.e. The value of the fpt paramtere should not appear in the list of types provided as the value of the subtypes parameter.</t>

</section>
</section>
</section>
<section anchor="example-condition" title="Example Condition">

<t>An example condition (PREIMAGE-SHA-256):</t>

<figure><artwork><![CDATA[
0x00000000 A0 25 80 20 7F 83 B1 65 7F F1 FC 53 B9 2D C1 81 .%.....e...S.-..
0x00000010 48 A1 D6 5D FC 2D 4B 1F A3 D6 77 28 4A DD D2 00 H..].-K...w(J...
0x00000020 12 6D 90 69 81 01 0C                            .m.i...

ni:///sha-256;f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk?fpt=preimage-sha-256&cost=12
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>scheme</c>
      <c><spanx style="verb">ni:///</spanx></c>
      <c>The named information scheme.</c>
      <c>hash function name</c>
      <c><spanx style="verb">sha-256</spanx></c>
      <c>The fingerprint is hashed with the SHA-256 digest function</c>
      <c>fingerprint</c>
      <c><spanx style="verb">f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk</spanx></c>
      <c>The fingerprint for this condition.</c>
      <c>type</c>
      <c><spanx style="verb">preimage-sha-256</spanx></c>
      <c>This is a <xref target="preimage-sha-256-condition-type">PREIMAGE-SHA-256</xref> condition.</c>
      <c>cost</c>
      <c><spanx style="verb">12</spanx></c>
      <c>The fulfillment payload is 12 bytes long, therefore the cost is 12.</c>
</texttable>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3280;
&RFC4055;
&RFC4648;
&RFC6920;
&RFC8017;
&I-D.draft-irtf-cfrg-eddsa-08;
<reference anchor="itu.X680.2015" target="http://handle.itu.int/11.1002/1000/12479">
  <front>
    <title>Information technology â€“ Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X690.2015" target="http://handle.itu.int/11.1002/1000/12483">
  <front>
    <title>Information technology â€“ ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This specification has a normative dependency on a number of other specifications with extensive security considerations therefore the consideratons defined for SHA-256 hashing and RSA signatures in <xref target="RFC8017"></xref> and <xref target="RFC4055"></xref> and for ED25519 signatures in <xref target="I-D.irtf-cfrg-eddsa"></xref> must be considered.</t>

<t>The cost and subtypes values of conditions are provided to allow implementations to evaluate their ability to validate a fulfillment for the given condition later.</t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --></t>

<t>For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--
]]></artwork></figure>

<t>Crypto-Conditions DEFINITIONS AUTOMATIC TAGS ::= BEGIN</t>

<figure><artwork><![CDATA[
-- Conditions

Condition ::= CHOICE {
  preimageSha256   [0] SimpleSha256Condition,
  prefixSha256     [1] CompoundSha256Condition,
  thresholdSha256  [2] CompoundSha256Condition,
  rsaSha256        [3] SimpleSha256Condition,
  ed25519Sha256    [4] SimpleSha256Condition
}

SimpleSha256Condition ::= SEQUENCE {
  fingerprint          OCTET STRING (SIZE(32)),
  cost                 INTEGER (0..4294967295)
}

CompoundSha256Condition ::= SEQUENCE {
  fingerprint          OCTET STRING (SIZE(32)),
  cost                 INTEGER (0..4294967295),
  subtypes             ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256   (0),
  prefixSha256     (1),
  thresholdSha256  (2),
  rsaSha256        (3),
  ed25519Sha256    (4)
}

-- Fulfillments

Fulfillment ::= CHOICE {
  preimageSha256   [0] PreimageFulfillment ,
  prefixSha256     [1] PrefixFulfillment,
  thresholdSha256  [2] ThresholdFulfillment,
  rsaSha256        [3] RsaSha256Fulfillment,
  ed25519Sha256    [4] Ed25519Sha512Fulfillment
}

PreimageFulfillment ::= SEQUENCE {
  preimage             OCTET STRING
}

PrefixFulfillment ::= SEQUENCE {
  prefix               OCTET STRING,
  maxMessageLength     INTEGER (0..4294967295),
  subfulfillment       Fulfillment
}

ThresholdFulfillment ::= SEQUENCE {
  subfulfillments      SET OF Fulfillment,
  subconditions        SET OF Condition
}

RsaSha256Fulfillment ::= SEQUENCE {
  modulus              OCTET STRING,
  signature            OCTET STRING
}

Ed25519Sha512Fulfillment ::= SEQUENCE {
  publicKey            OCTET STRING (SIZE(32)),
  signature            OCTET STRING (SIZE(64))
}

-- Fingerprint Content

-- The PREIMAGE-SHA-256 condition fingerprint content is not DER encoded
-- The fingerprint content is the preimage

PrefixFingerprintContents ::= SEQUENCE {
  prefix               OCTET STRING,
  maxMessageLength     INTEGER (0..4294967295),
  subcondition         Condition
}

ThresholdFingerprintContents ::= SEQUENCE {
  threshold            INTEGER (1..65535),
  subconditions        SET OF Condition
}

RsaFingerprintContents ::= SEQUENCE {
  modulus              OCTET STRING
}

Ed25519FingerprintContents ::= SEQUENCE {
  publicKey            OCTET STRING (SIZE(32))
}
]]></artwork></figure>

<t>END</t>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types-table">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>ED25519</c>
</texttable>

</section>
</section>


  </back>

<!-- ##markdown-source:
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
uxnfox1mm+DrF/WXNr748eT/ANZUpKsB3gAA

-->

</rfc>

