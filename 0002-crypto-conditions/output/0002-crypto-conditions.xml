<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.39 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3447 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-04 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-04.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-02" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="A." surname="Hope-Bailie" fullname="Adrian Hope-Bailie">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>adrian@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2016" month="November" day="11"/>

    <area>security</area>
    
    

    <abstract>


<t>Crypto-conditions defines a set of encoding formats and data structures for conditions and fulfillments.  A condition uniquely identifies a boolean circuit constructed from one or more logic gates, evaluated by either validating a cryptographic signature or verifying the preimage of a hash digest. A fulfillment is a data structure encoding one or more cryptographic signatures and hash digest preimages that can be used to evaluate the result of the circuit.</t>

<t>A fulfillment is validated by evaluating the circuit but also verifying that the provided fulfillment matches the circuit fingerprint, the condition.</t>

<t>Since evaluation of some of the logic gates in the circuit (those that are signatures) also take a message as input the evaluation of the entire fulfillment takes an optional input message which is passed to each logic gate as required. As such the algorithm to validate a fulfillment against a condition and a message matches that of other signature schemes and a crypto-condition can serve as a sophisticated and flexible replacement for a simple signature where the condition is used as the public key and the fulfillment as the signature.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Crypto-conditions is a scheme for composing signature-like structures from one or more existing signature scheme or hash digest primitives. It defines a mechanism for these existing primitives to be combined and grouped to create complex signature arrangements but still maintain the useful properties of a simple signature, most notably, that a deterministic algorithm exists to verify the signature against a message given a public key.</t>

<t>Using crypto-conditions, existing primitives such as RSA and ED25519 signature schemes and SHA256 digest algorithms can be used as logic gates to construct complex boolean circuits which can then be used as a compound signature. The validation function for these compound signatures takes as input the fingerprint of the circuit, called the condition, the circuit definition and minimum required logic gates with their inputs, called the fulfillment, and a message.</t>

<t>The function returns a boolean indicating if the compound signature is valid or not. This property of crypto-conditions means they can be used in most scenarios as a replacement for existing signature schemes which also take as input, a public key (the condition), a signature (the fulfillment), and a message and return a boolean result.</t>

</section>
<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

</section>
<section anchor="types" title="Types">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>The different structures of different crypto-conditions and the algorithms they employ is defined by the type of the crypto-condition.</t>

<section anchor="simple-and-compound-types" title="Simple and Compound Types">

<t>Two categories of crypto-condition type exist. Simple crypto-conditions provide a standard encoding for existing primitives such as RSA and ED25519 signatures, or SHA256 hash digests where many of the scheme parameters have hardcoded values. As such multiple simple types maybe be defined to encode the same underlying scheme but where the parameters differ.</t>

<t>As an example, the types defined in this version of the specification all use the SHA-256 digest algorithm for derivation of the condition fingerprint. If a future version were to introduce SHA-512 as an alternative this would require that new types be defined for each existing type that must have its condition derived using SHA-512.</t>

<t>Compound crypto-conditions contain one or more sub-crypto-conditions. Compound crypto-conditions are used to construct the branches of the boolean circuit where a compound condition will evaluate to TRUE or FALSE based on the output of the evaluation of their sub-crypto-conditions.</t>

<t>A compound crypto-condition may have multiple branches and be defined to evaluate to TRUE even if only a subset of these evaluate to TRUE (as in an m-of-n signature scheme). As such the valid fulfillment of a compound condition could contain a combination of sub-fulfillments (that can be evaluated) but also sub-conditions that are simply used (in combination with the derived conditions from the sub-fulfillments) to derive the compound condition and compare this to the condition provided for validation.</t>

</section>
<section anchor="defining-and-supporting-new-types" title="Defining and supporting New types">

<t>The crypto-conditions format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>Implementations are not required to support all condition types therefor it is necessary to indicate which types an implementation must support in order to validate a fulfillment. For this reason, compound conditions are encoded with an additional field, subtypes, indicating the set of types and subtypes of all sub-crypto-conditions.</t>

</section>
</section>
<section anchor="features" title="Features">

<t>Crypto-conditions offer many of the features required of a regular signature scheme but also others which make them useful in a variety of new use cases.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">

<t>Each condition type uses one or more cryptographic primitives such as digest or signature algorithms. Compound types may contain sub-crypto-conditions of any type and indicate the set of underlying types in the subtypes field of the condition</t>

<t>To verify that a given implementation can verify a fulfillment for a given condition, implementations MUST ensure they are able to validate fulfillments of all types indicated in the subtypes field of a compound condition. If an implementation encounters an unknown type it MUST reject the condition as it will almost certainly be unable to validate the fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility.</t>

<t>Protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Wayne and Alf. Alf's condition can be a signature condition while Wayne's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Multi-level signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Mac, and Ped must approve; or Smithers must approve."</t>

</section>
<section anchor="crypto-conditions-as-a-signature-scheme" title="Crypto-conditions as a signature scheme">

<t>Crypto-conditions is a signature scheme for compound signatures which has similar properties to most other signature schemes, such as:
  1. Validation of the signature (the fulfillment) is done using a public key (the condition) and a message as input
  2. The same public key can be used to validate multiple different signatures, each against a different message
  3. It is not possible to derive the signature from the public key</t>

<t>However, the scheme also has a number of features that make it unique such as:
  1. It is possible to derive the same public key from any valid signature without the message
  2. It is possible for the same public key and message to be used to validate multiple signatures. For example, the fulfillment of an m-of-n condition will be different for each combination of n signatures.
  4. Composite signatures use one or more other signatures as components allowing for recursive signature validation logic to be defined.<vspace />
  3. A valid signature can be produced using different combinations of private keys if the structure of the compound signature requires only specific combinations of internal signatures to be valid  (m of n signature scheme).</t>

</section>
<section anchor="crypto-conditions-as-a-trigger-in-distributed-systems" title="Crypto-conditions as a trigger in distributed systems">

<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time and resource-consuming aspects of the transaction are prepared by all participants following which a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consists of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>Crypto-conditions defines a mechanism for expressing these triggers as pairs of unique trigger identifiers (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>It is also important that all participants in such a distributed system are able to evaluate, prior to the trigger being fired, that they will be capable of verifying the trigger. Determinism is useless if validation of the trigger requires algorithms or resources that are not available to all participants.</t>

<t>Therefor conditions may be used as <spanx style="strong">distributable event descriptions</spanx> in the form of a <spanx style="emph">fingerprint</spanx>, but also <spanx style="emph">event meta-data</spanx> that allows the event verification system to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap size or memory) to verify the event notification later.</t>

<t>Fulfillments are therefor <spanx style="strong">cryptographically verifiable event notifications</spanx> can be used to verify that the event occurred but also matches the given description.</t>

<t>When using crypto-conditions as a trigger it will often make sense for the message that is used for validation to be empty to match the signature of the trigger processing system's API. This makes crypto-conditions compatible with systems that use simple hash-locks as triggers.</t>

<t>If a PKI signature scheme is being used for the triggers this would require a new key pair for each trigger which is impractical. Therefor the PREFIX compound type wraps a sub-crypto-condition with a message prefix that is applied to the message before signature validation. In this way a unique condition can be derived for each trigger even if the same key pair is re-used with an empty message.</t>

</section>
<section anchor="smart-signatures" title="Smart signatures">

<t>In the Interledger protocol, fulfillments provide irrepudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchronizes multiple transfers on distinct ledgers in an almost atomic end-to-end transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying cryptographic primitives are correctly implemented.</t>

</section>
</section>
<section anchor="validation-of-a-fulfillment" title="Validation of a fulfillment">

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, the following steps.</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>If the fulfillment is a simple crypto-condition AND is based upon a signature scheme (such as RSA-PSS or ED25519) then any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M) (which may be empty).</t>
  <t>If the fulfillment is a compound crypto-condition then the sub-fulfillments MUST each be validated. In the case of the PREFIX-SHA-256 type the sub-fulfillment MUST be valid for F to be valid and in the case of the THRESHOLD-SHA-256 type the number of valid sub-fulfillments must be equal or greater than the threshold defined in F.</t>
</list></t>

<t>If the derived condition (D) matches the input condition (C) AND the boolean circuit defined by the fulfillment evaluates to TRUE then the fulfillment (F) fulfills the condition (C).</t>

<t>A more detailed validation algorithm for each crypto-condition type is provided with the details of the type later in this document. In each case the notation F.x or C.y implies; the decoded value of the field named x of the fulfillment and the decoded value of the field named y of the Condition respectively.</t>

<section anchor="subfulfillments" title="Subfulfillments">

<t>In validating a fulfillment for a compound crypto-condition it is necessary to validate one or more sub-fulfillments per step 3 above. In this instance the condition for one or more of these sub-fulfillments is often not available for comparison with the derived condition. Implementations MUST skip the first fulfillment validation step as defined above and only perform steps 2 and 3 of the validation.</t>

<t>The message (M) used to validate sub-fulfillments is the same message (M) used to validate F howvere in the case of the PREFIX-SHA-256 type this is prefixed with F.prefix before validation of the sub-fulfillment is performed.</t>

</section>
</section>
<section anchor="deriving-the-condition" title="Deriving the Condition">

<t>Since conditions provide a unique fingerprint for fulfillments it is important that a determinisitic algorithm is used to derive a condition. For each crypto-condition type details are provided on how to:</t>

<t><list style="numbers">
  <t>Assemble the fingerprint content and if neccessary calculate the hash digest of this data.</t>
  <t>Calculate the maximum fulfillment length of a fulfillment</t>
</list></t>

<t>For compound types the fingerprint content will contain the complete, encoded, condition for all sub-crypto-conditions. Implementations MUST abide by the ordering rules provided when assembling the fingerprint content.</t>

<t>When calculating the fingerprint of a compound crypto-condition implementations MUST first derive the condition for all sub-fulfillments and include these conditions when assembling the fingerprint content.</t>

<section anchor="conditions-as-public-keys" title="Conditions as Public Keys">

<t>Since the condition is just a fingerprint and meta-data about the crypto-condition it can be transmitted freely in the same way a public key is shared publicly. It's not possible to derive the fulfillment from the condition.</t>

</section>
</section>
<section anchor="format" title="Format">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>.</t>

<section anchor="encoding-rules" title="Encoding Rules">

<t>Implementations of this spec MUST support encoding and decoding using Octet Encoding Rules (OER) as defined in <xref target="itu.X696.2015"></xref>. This is the canonical encoding format. Where alternate encoding rules are defined and used these should be applied through to all ASN.1 defined data structures.</t>

<t>For example, implementations that choose to use DER encoding should also use DER encoding when assembling the content of a condition fingerprint before it is hashed.</t>

</section>
<section anchor="condition-format" title="Condition">

<t>The binary encoding of conditions is dependant on their type. The overall size of conditions is not fixed as some types (compound conditions) contain additional fields (subtypes) and the algorithm for deriving the fingerprint differs by type therefor the fingerprint size also differs.</t>

<t>Conditions are encoded as follows:</t>

<figure><artwork><![CDATA[
Condition ::= SEQUENCE {
  type BIT STRING,
  subtypes BIT STRING
  fingerprint OCTET STRING,
  maxFulfillmentLength INTEGER (0..MAX),
}
]]></artwork></figure>

<section anchor="type" title="Type">

<t>Type is a bitmap that indicates the type of the crypto-condition.</t>

<t>Each bit in the bitmap represents a type. The list of known types is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type.</t>

<t>A bitmap is used (even though only a single bit should be set) for consistency with the subtypes field. Implementations that encounter a type bitmap with zero, or more than one, bit(s) set MUST reject the condition.</t>

<t>In future new types may introduce new formats so this field is variable length and can expand as required.</t>

</section>
<section anchor="subtypes" title="Subtypes">

<t>Subtypes is a bitmap that indicates the set of types an implementation must support in order to be able to successfully validate the fulfillment of this condition. This is the set of types and subtypes of the top-level condition and all sub-crypto-conditions, recursively.</t>

<t>It must be possible to verify that all types used in a crypto-condition are supported (including the types and subtypes of any sub-crypto-conditions) even if the fulfillment is not available to be analysed yet. Therefore, all compound conditions set the bits in this bitmap that correspond to the set of types and subtypes of all sub-crypto-conditions and the bit corresponding to their own type.</t>

<t>For compound conditions multiple bits will be set however for simple conditions this field should be equal to the types field.</t>

<t>Implementations that encounter a condition with any of the simple types (PREIMAGE-SHA-256, RSA-SHA-256 or ED25519) and a subtypes field that is not equal to the types field MUSt reject the condition.</t>

<t>The field is encoded as a variable length BIT STRING as defined in ASN.1 to accommodate new types that may be defined.</t>

<t>As with the types field, each bit in the bitmap represents a type for the list of known types in the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type.</t>

<t>The presence of one of more sub-crypto-conditions of a specific type is indicated by setting the numbered bit corresponding to the type ID of that type.</t>

<t>For example, a compound condition that contains an ED25519 crypto-condition as a sub-crypto-condition will set the bit at position 4.</t>

<t>Bits are numbered per the encoding rules for the ASN.1 BIT STRING type.</t>

</section>
<section anchor="fingerprint" title="Fingerprint">

<t>The fingerprint is an octet string uniquely representing the condition with respect to other conditions of the same type.</t>

<t>Implementations which index conditions MUST use the entire encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint.</t>

<t>For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key.</t>

<t>For types that use PKI signature schemes, the signature is intentionally not included in the content that is used to compose the fingerprint. This meansthe fingerprint can be calculated without needing to know the message or having access to the private key.</t>

<t>Future types may use different functions to produce the fingerprint which may have different lengths therefor the filed is encoded as a variable length string.</t>

</section>
<section anchor="maxfulfillmentlength" title="MaxFulfillmentLength">

<t>This is the maximum length of the essential fulfillment payload for a fulfillment that can fulfill this condition.</t>

<t>For each crypto-condition type, a formula is provided for calculating the maximum fulfillment length to ensure that implementations produce consistent output.</t>

<t>When a crypto-condition is submitted to an implementation, this implementation MUST verify that it will be able to process a fulfillment with a payload of size maxFulfillmentLength plus any additional encoding bytes.</t>

</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">

<t>Like conditions, the binary encoding of fulfillments is dependant on their type. 
Unlike conditions there is little commonality between types, the only common field being the type which is encoded in the first byte.</t>

<t>Therefor the ASN.1 definition for fulfillments is defined as follows and the format of the payload is defined per type:</t>

<figure><artwork><![CDATA[
Fulfillment ::= SEQUENCE {
  type BIT STRING,
  payload OCTET STRING,
}
]]></artwork></figure>

<section anchor="type-1" title="Type">

<t>Type is a bitmap that indicates the type of the crypto-condition. The type field of a fulfillment is identical to the type field for the corresponding condition.</t>

</section>
<section anchor="payload" title="Payload">

<t>The paylod of a fulfillment varies greatly by crypto-condition type therefor a fulfillment has a generic payload field which is a variable length octet string the sub-field of which are defined for each crypto-condition type.</t>

</section>
</section>
</section>
<section anchor="crypto-condition-types" title="Crypto-Condition Types">
<t>The following condition types are defined in this version of the specification. Future versions of this spec MAY introduce new feature suites and condition types, which SHALL be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">

<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the availability of the SHA-256 digest algorithm.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment as the validation of this crypto-condition type only requires that the SHA-256 digest of the preimage, taken from the fulfillment, matches the fingerprint, taken from the condition.</t>

<section anchor="preimage-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the size, in bytes, of the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment payload is simply the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-validating" title="Validating">

<t>A PREIMAGE-SHA-256 fulfillment is valid iff C.fingerprint is equal to the SHA-256 hash digest of F.preimage.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the availability of the SHA-256 digest algorithm and is a compound crypto-condition type.</t>

<t>Prefix crypto-conditions provide a way to effectively narrow the scope of other crypto-conditions.</t>

<t>A condition is the fingerprint of a public key used to sign an arbitrary message. By creating a prefix crypto-condition that wraps another condition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>We can also use the prefix condition in contexts where there is an empty message used for validation of the fulfillment so that we can reuse the same key pair for multiple fulfillments, each with a different prefix, and therefore generate a unique condition each time.</t>

<t>Implementations MUST prepend the prefix to the provided message and will use the resulting value as the message to validate the sub-fulfillment.</t>

<section anchor="prefix-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the fingerprint contents as defined below:</t>

<figure><artwork><![CDATA[
PrefixSha256ConditionFingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subcondition'>
  is the sub-condition derived from the sub-fulfillment.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the size, in bytes, of the prefix plus the maxFulfillmentLength of the sub-crypto-condition.</t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
PrefixSha256FulfillmentPayload ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment Fulfillment
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subfulfillment'>
  is the fulfilled subcondition.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-validating" title="Validating">

<t>A PREFIX-SHA-256 fulfillment is valid iff:</t>

<t><list style="numbers">
  <t>F.subfulfillment is valid, where the message used for validation of F.subfulfillment is M prefixed by F.prefix AND</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the availability of the SHA-256 digest algorithm and is a compound crypto-condition type.</t>

<section anchor="threshold-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (1..255),
  subconditions SEQUENCE OF Condition,
}
]]></artwork></figure>

<t>The list of sub-conditions is sorted first based on length, shortest first. Elements of the same length are sorted in lexicographic (big-endian) order, smallest first.</t>

<t><list style="hanging">
  <t hangText='threshold'>
  threshold MUST be an integer in the range 1 … 255. In order to fulfill a threshold condition, the number of valid sub-fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions either provided in the fulfillment or derived from the sub-fulfillments provided.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the sum of the maxFulfillmentLength of all sub-conditions and sub-fulfillments.</t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
ThresholdSha256FulfillmentPayload ::= SEQUENCE {
  threshold INTEGER (1..255),
  subfulfillments SEQUENCE OF Fulfillment
  subconditions SEQUENCE OF Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='threshold'>
  is a number and MUST be an integer in the range 1 … 255. In order to fulfill a threshold condition, the sum of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subfulfillments'>
  is the set of sub-fulfillments.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions provided in place of any unfufilled sub-fulfillment.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-validating" title="Validating">

<t>A THRESHOLD-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>The number of valid F.subfulfillments is equal to or greater than F.threshold.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256  digest algorithm and the RSA-PSS signature scheme.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC3447"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefor, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC3447"></xref>. Implementations MUST also use a salt length of 32 bytes (equal to the size of the output from the SHA-256 algorithm). Therefore the algorithm identifier will have the following value:</t>

<figure><artwork><![CDATA[
rSASSA-PSS-Crypto-Conditions-Identifier  RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS,
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha256,
        maskGenAlgorithm    mgf1SHA256,
        saltLength          32,
        trailerField        trailerFieldBC
    }
}
   
sha256 HashAlgorithm ::= {
    algorithm   id-sha256,
    parameters  NULL
}

mgf1SHA256 MaskGenAlgorithm ::= {
    algorithm   id-mgf1,
    parameters  HashAlgorithm : sha256
}
]]></artwork></figure>

<section anchor="rsa-sha-256-condition-type-condition" title="Condition Format">
<t>The fingerprint of a RSA-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
RsaSha256FingerprintContents ::= SEQUENCE {
  modulus OCTET STRING (SIZE(128..512))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  is an octet string representing the RSA public modulus in big-endian byte order. The first byte of the modulus MUST NOT be zero.</t>
  <t>The corresponding public exponent e is assumed to be 65537 as recommended in <xref target="RFC4871"></xref> . Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref> .</t>
  <t>Implementations MUST reject moduli smaller than 128 bytes (1017 bits) or greater than 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref> . OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref> .</t>
</list></t>

</section>
<section anchor="rsa-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the length in bytes of the modulus multiplied by 2.</t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
RsaSha256FulfillmentPayload ::= SEQUENCE {
  modulus OCTET STRING (SIZE(128..512)),
  signature OCTET STRING (SIZE(128..512))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  is an octet string representing the RSA public modulus in big-endian byte order. See <xref target="rsa-sha-256-condition-type-condition"></xref></t>
  <t hangText='signature'>
  is an octet string representing the RSA signature. It MUST be encoded in big-endian byte order with the exact same number of octets as the modulus, even if this means adding leading zeros. This ensures that the fulfillment size is constant and known ahead of time. Note that the field is still binary encoded with a length prefix for consistency.</t>
  <t>Implementations MUST verify that the signature and modulus consist of the same number of octets and that the signature is numerically less than the modulus.</t>
</list></t>

<t>The message to be signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-implementation" title="Implementation">
<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref> . In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-condition-type-validating" title="Validating">

<t>An RSA-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the RSA public key derived using a modulus of F.modulus and an exponent of 65537.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="ed25519-condition-type" title="ED25519">
<t>ED25519 is assigned the type ID 4. It relies on the SHA-512 digest algorithm and the ED25519 signature scheme as the condition fingerprint is not a digest.</t>

<t>The exact algorithm and encodings used for the public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function.</t>

<section anchor="ed25519-condition-type-condition" title="Condition Format">

<t>The fingerprint of an ED25519 condition is the 32 byte Ed25519 public key. Since the public key is already very small, we do not hash it.</t>

</section>
<section anchor="ed25519-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
Ed25519FulfillmentPayload ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='publicKey'>
  is an octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  is an octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="ed25519-sha-256-condition-type-validating" title="Validating">

<t>An ED25519 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the ED25519 public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="example" title="Example">

<t>TODO</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3447;
&RFC4648;
&I-D.draft-irtf-cfrg-eddsa-04;
<reference anchor="itu.X680.2015" target="https://www.itu.int/rec/T-REC-X.680-201508-I/">
  <front>
    <title>Information technology – Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X696.2015" target="http://handle.itu.int/11.1002/1000/12487">
  <front>
    <title>Information technology – ASN.1 encoding rules: Specification of Octet Encoding Rules (OER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This section to be expanded in a later draft. <!-- TODO --></t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --> For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--

CryptoConditions
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

/**
* CONTAINERS
*/

Condition ::= SEQUENCE {
    type BIT STRING,
    subtypes BIT STRING,
    fingerprint OCTET STRING,
    maxFulfillmentLength INTEGER (0..MAX)
}

Fulfillment ::= SEQUENCE {
    type BIT STRING,
    payload OCTET STRING
}
    
/**
* FULFILLMENT PAYLOADS
*/

-- For preimage conditions, the payload equals the preimage

PrefixSha256FulfillmentPayload ::= SEQUENCE {
    prefix OCTET STRING,
    subfulfillment Fulfillment
}

ThresholdSha256FulfillmentPayload ::= SEQUENCE {
    threshold INTEGER (1..255),
    subfulfillments SEQUENCE OF Fulfillment,
    subconditions SEQUENCE OF Condition
}

RsaSha256FulfillmentPayload ::= SEQUENCE {
    modulus OCTET STRING (SIZE(128..512)),
    signature OCTET STRING (SIZE(128..512))
}

Ed25519FulfillmentPayload ::= SEQUENCE {
    publicKey OCTET STRING (SIZE(32)),
    signature OCTET STRING (SIZE(64))
}

/**
* FINGERPRINTS
*/

-- SHA-256 hash of the fingerprint contents
Sha256Fingerprint ::= OCTET STRING (SIZE(32)) -- digest

-- 32-byte Ed25519 public key
Ed25519Fingerprint ::= OCTET STRING (SIZE(32)) -- publicKey

/**
* FINGERPRINT CONTENTS
*
* The content that will be hashed to arrive at the fingerprint.
*/

-- The preimage type hashes the raw contents of the preimage

PrefixSha256FingerprintContents ::= SEQUENCE {
    prefix OCTET STRING,
    condition Condition
}

ThresholdSha256FingerprintContents ::= SEQUENCE {
    threshold INTEGER (1..255),
    subconditions SEQUENCE OF Condition
}

RsaSha256FingerprintContents ::= SEQUENCE {
    modulus OCTET STRING (SIZE(128..512))
}

/**
* EXAMPLES
*/

exampleCondition Condition ::=
{
    type '1'B,
    subtypes '1'B,
    fingerprint '
    E3B0C442 98FC1C14 9AFBF4C8 996FB924 27AE41E4 649B934C A495991B 7852B855
    'H,
    maxFulfillmentLength 2,
}

exampleFulfillment Fulfillment ::=
{
    type '1'B,
    payload '00'H
}

exampleRsaSha256FulfillmentPayload RsaSha256FulfillmentPayload ::=
{
    modulus '
    B30E7A93 8783BABF 836850FF 49E14F87 E3F92D5C 46E33FEC A3E4F0B2 2358580B
    11765995 F4B8EEA7 FB4712C2 E1E316F7 F775A953 D232216A 169D9A64 DDC00712
    0A400B37 F2AFC077 B62FE304 DE74DE6A 119EC407 6B529C4F 6096B0BA AD4F533D
    F0173B9B 822FD85D 65FA4BEF A92D8F52 4F69CBCA 0136BD80 D095C169 AEC0E095
    'H,
    signature '
    48E8945E FE007556 D5BF4D5F 249E4808 F7307E29 511D3262 DAEF61D8 8098F9AA
    4A8BC062 3A8C9757 38F65D6B F459D543 F289D73C BC7AF4EA 3A33FBF3 EC444044
    7911D722 94091E56 1833628E 49A772ED 608DE6C4 4595A91E 3E17D6CF 5EC3B252
    8D63D2AD D6463989 B12EEC57 7DF64709 60DF6832 A9D84C36 0D1C217A D64C8625
    BDB594FB 0ADA086C DECBBDE5 80D424BF 9746D2F0 C312826D BBB00AD6 8B52C4CB
    7D47156B A35E3A98 1C973863 792CC80D 04A18021 0A524158 65B64B3A 61774B1D
    3975D78A 98B0821E E55CA0F8 6305D425 29E10EB0 15CEFD40 2FB59B2A BB8DEEE5
    2A6F2447 D2284603 D219CD4E 8CF9CFFD D5498889 C3780B59 DD6A57EF 7D732620
    'H
}

exampleEd25519FulfillmentPayload Ed25519FulfillmentPayload ::=
{
    publicKey '
    EC172B93 AD5E563B F4932C70 E1245034 C35467EF 2EFD4D64 EBF81968 3467E2BF
    'H,
    signature '
    B62291FA D9432F8F 298B9C4A 4895DBE2 93F6FFDA 1A68DADF 0CCDEF5F 47A0C721
    2A5FEA3C DA97A3F4 C03EA9F2 E8AC1CEC 86A51D45 2127ABDB A09D1B6F 331C070A
    'H
}

END
]]></artwork></figure>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types-table">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>ED25519</c>
</texttable>

</section>
</section>
<section anchor="appendix-f" title="String Encoding">

<t>Implementations MAY support one or both string encoding formats which encode conditions and fulfillments as either URIs or JSON objects. The binary encoding is considered the canonical encoding.</t>

<t>The following string encoding types are defined:</t>

<t><list style="hanging">
  <t hangText='BASE10'>
  Variable-length integer encoded as a base-10 (decimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows.</t>
  <t hangText='BASE16'>
  Variable-length integer encoded as a base-16 (hexadecimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows. Encodings may have an odd number of characters as the encoding excludes leading zeros.</t>
  <t hangText='BASE64URL'>
  Base64-URL encoding. See <xref target="RFC4648"></xref>, Section 5.</t>
</list></t>

<section anchor="string-condition-format" title="Condition URI Format">

<t>Conditions are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cc:" BASE10(type) ":" BASE64URL(fingerprint) ":" 
BASE10(maxFulfillmentLength) ":" BASE16(subtypes) 
]]></artwork></figure>

<t>For simple types the subtypes field (and ":" prefix) may be excluded.</t>

<section anchor="example-condition" title="Example Condition">

<t>An example condition:</t>

<figure><artwork><![CDATA[
0x00000000 00 00 01 03 20 7F 83 B1 65 7F F1 FC 53 B9 2D C1 ........e...S.-.
0x00000010 81 48 A1 D6 5D FC 2D 4B 1F A3 D6 77 28 4A DD D2 .H..].-K...w(J..
0x00000020 00 12 6D 90 69 03 FF FF FF                      ..m.i....

cc:0:dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA:66
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cc</spanx></c>
      <c>Constant. Indicates this is a condition.</c>
      <c>type</c>
      <c><spanx style="verb">0</spanx></c>
      <c>Type 0 is [PREIMAGE-SHA-256][].</c>
      <c>fingerprint</c>
      <c><spanx style="verb">dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA</spanx></c>
      <c>The hash of the fulfillment for this condition.</c>
      <c>maxFulfillmentLength</c>
      <c><spanx style="verb">66</spanx></c>
      <c>The fulfillment payload is 66 bytes long, before being BASE64URL-encoded.</c>
      <c>subtypes</c>
      <c>``</c>
      <c>Absent</c>
</texttable>

</section>
<section anchor="string-fulfillment-format" title="Fulfillment URI Format">

<t>Fulfillments are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cf:" BASE10(type) ":" BASE64URL(payload)
]]></artwork></figure>

</section>
<section anchor="example-fulfillment" title="Example Fulfillment">

<t>The following is an example fulfillment in string format, for the <xref target="example-condition">example condition</xref>:</t>

<figure><artwork><![CDATA[
cf:0:VGhlIG9ubHkgYmFzaXMgZm9yIGdvb2QgU29jaWV0eSBpcyB1bmxpbWl0ZWQgY3JlZGl0LuKAlE9zY2FyIFdpbGRl
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cf</spanx></c>
      <c>Constant. Indicates this is a fulfillment.</c>
      <c>type</c>
      <c><spanx style="verb">0</spanx></c>
      <c>Type 0 is [PREIMAGE-SHA-256][].</c>
      <c>payload</c>
      <c><spanx style="verb">VGhlIG...pbGRl</spanx></c>
      <c>The BASE64URL-encoded SHA-256 preimage of the condition, since this is a PREIMAGE-SHA-256 type fulfillment. In this case, it is an arbitrary string.</c>
</texttable>

</section>
</section>
</section>


  </back>

<!-- ##markdown-source:
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
H9N3ioyLz7N3fKbfa8L4XRV6mY0/iiF7aWYYOSDX2PzUlD9C/gc2Vlu0mqKP
fgeYimBp4ee5J+YTAR7CeChaUzGhunH6CeD/20a94YwHPDnwQOGLkQcWpACj
Hp6G5zpj4YFd38YvwXNoDcB8BlsJTCrReN1o/NiofwPDPZ3+qeGO1yLgvJYA
U3LYFGD3A5TgEfF/lT+NxqYRIoDGS4YNbV6sxvXBeuF1rlZv+91xuv3p3eND
Z9W/9+PlxzBKbyKvfXP70/tN+v3ootfTyT711rlCGaqfyxdRZqT1nDpLrS44
QwC/p9ZR47YSdLXfEc145AeVFpIG1rUXpv95ufwZf09ksQam2s2hOmGmWqr0
OTo4FrnF5aX83PyZtSpebuKTH4oK+scPP/IQdnzAHuILtuBnnOrBPe2t+HKR
4tmvOHVloACm7vUIE3cPB4806PVkxRW++qqmjuvm85o079eltODJNKcWUPUz
/x4tsOgH7iylLqvkVeWZVnNHYR+TWevjMksu9MwVFnYMvWijcjO6vNFJ+cVK
ozOYNZ2n+lASNyC+5XdWyZSEGUBuXnz76iG6fDXcLV5/vP9hM//F//7q/i+b
4f7y1epx0frz/fvW8K/+d982g9vxdrkfe4vNp+3iu6j5l+/+fP9D+0/RX15F
zTe7b0bRbPjLD635/nK+2i5e3UT/n/Dv+hn8a7et/KM4WPFFcQjeLhCuhGTF
pCX20EF4HUPW7+zWicJMlgOoZZTMfT6gy16ces0PZkdr8rAgp9VYnhyILPd/
AWMFj1nUqgAA

-->

</rfc>

