<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.31 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3447 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC4648 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-04 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-04.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-01" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2016" month="October" day="25"/>

    <area>security</area>
    
    

    <abstract>


<t>Crypto-conditions provide a mechanism to describe a signed message such that multiple actors in a distributed system can all verify the same signed message and agree on whether it matches the description. This provides a useful primitive for event-based systems that are distributed on the Internet since we can describe events in a standard deterministic manner (represented by a fingerprint and some meta-data, called the condition) and therefore define distiributed event handlers which evaluate the proof of the event occuring (represented by a public key and signature, called the fulfillment) with deterministic outcomes.</t>

<t>This specification describes a message format for conditions and fulfillments and the canonical binary encodings for each. It also describes alternate string encodings in both a compact URI form and extended JSON form.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time-consuming aspects of the transaction are prepared across all participants and a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consist of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>This document specifies a mechanism for defining these triggers as pairs of trigger descriptions (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>The crypto-conditions specification defines two message types, a condition is a <spanx style="strong">distributable event description</spanx> in the form of an a <spanx style="emph">fingerprint</spanx>, and <spanx style="emph">event meta-data</spanx> that allows the event verification systems to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap or memory) to verify the event later.</t>

<t>The second message type, fulfillments are <spanx style="strong">cryptographically verifiable event notifications</spanx> in the form of one or more public keys and signatures that can be used to verify that the event occurred and matches the description.</t>

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, involves two steps.</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>Any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M), which may be empty.</t>
</list></t>

<t>This property of crypto-conditions, makes them suitable as a replacement for other signature schemes where the condition (C) takes the place of the signature validation key, the fulfillment (F) takes the place of the signature and the message (M) is simply the message.</t>

<t>Since the condition is just a fingerprint and meta-data it can be transmitted freely. It's not possible to derive the fulfillment from the condition. Also, because the fingerprint is a digest it is a fixed size which makes it very efficient to encode and decode.</t>

<t>In the Interledger protocol, crypto-conditions and fulfillments provide irrepudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchoronizes multiple transfers on distinct ledgers in an almost atomic transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying crypto-primitives are correctly implemented.</t>

<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

<t>Within this specification, the term "condition" refers to the hash of a description of a signed message. The hash function must be preimage-resistant.</t>

<t>The term "fulfillment" refers to a description of a signed message and a signed message that matches the description. We hash the description and compare that to the condition, and also compare the signed message to the description. If the message matches the description and the hash of the description matches the condition, we say that the fulfillment fulfills the condition.</t>

<t>In the simplest case, the fulfillment can be a preimage that hashes to the condition, in which case the preimage is both the description and the message.</t>

</section>
<section anchor="features" title="Features">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>This format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>The <xref target="bitmask"></xref> of a crypto-condition indicates which algorithms it uses, so a compliant implementation can know whether it supports the functionality required to interpret the crypto-condition.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">
<t>The crypto-condition format contains a <xref target="bitmask"></xref> that specifies which hash function and signing scheme to use. Any message format for a condition or a fulfillment contains such a bitmask.</t>

<t>Implementations MAY state their supported algorithms by providing a bitmask in the same format. To verify that a given implementation can verify a fulfillment for a given condition, you compare the bitmasks. If all bits set in the condition's bitmask are also set in the implementation's bitmask, then the implementation can verify the condition's fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility.</t>

<t>Protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of weighted subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Agnes and Bruce. Agnes's condition can be a signature condition while Bruce's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Weighted signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Adi, and Leonard must approve; or Clifford must approve."</t>

</section>
</section>
</section>
<section anchor="format" title="Format">

<section anchor="binary-encoding" title="Binary Encoding">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>. Implementations of this spec MUST support encoding and decoding using Octet Encoding Rules (OER) as defined in <xref target="itu.X696.2015"></xref>.</t>

</section>
<section anchor="string-types" title="String Types">

<t>Crypto-conditions use the following types within string encoding:</t>

<t><list style="hanging">
  <t hangText='BASE10'>
  Variable-length integer encoded as a base-10 (decimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows.</t>
  <t hangText='BASE16'>
  Variable-length integer encoded as a base-16 (hexadecimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows. No leading zeros.</t>
  <t hangText='BASE64URL'>
  Base64-URL encoding. See <xref target="RFC4648"></xref>, Section 5.</t>
</list></t>

</section>
<section anchor="bitmask" title="Bitmask">
<t>Any system that accepts crypto-conditions must be able to state its supported algorithms. It must be possible to verify that all algorithms used in a certain condition are indeed supported even if the fulfillment is not available yet. Therefore, all conditions and fulfillments contain a bitmask to express the required features. Implementations provide a bitmask of features they support.</t>

<t>Each bit represents a different suite of features. Each type of crypto-condition depends on one or more feature suites. If an implementation supports all feature suites that a certain type depends on, the implementation MUST support that condition type. The list of known types and feature suites is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> .</t>

<t>To save space, the bitmask is encoded as a variable-length integer.</t>

</section>
<section anchor="condition-format" title="Condition">
<t>Below are the string and binary encoding formats for a condition.</t>

<section anchor="string-condition-format" title="String Format">

<t>Conditions are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cc:" BASE16(type) ":" BASE16(featureBitmask) ":"
    BASE64URL(fingerprint) ":" BASE10(maxFulfillmentLength)
]]></artwork></figure>

</section>
<section anchor="binary-condition-format" title="Binary Format">

<t>Conditions are binary encoded as:</t>

<figure><artwork><![CDATA[
Condition ::= SEQUENCE {
  type ConditionType,
  featureBitmask INTEGER (0..MAX),
  fingerprint OCTET STRING,
  maxFulfillmentLength INTEGER (0..MAX)
}

ConditionType ::= INTEGER {
  preimageSha256(0),
  rsaSha256(1),
  prefixSha256(2),
  thresholdSha256(3),
  ed25519(4)
} (0..65535)
]]></artwork></figure>

</section>
<section anchor="condition-format-fields" title="Fields">

<t><list style="hanging">
  <t hangText='type'>
  is the numeric type identifier representing the condition type.</t>
  <t hangText='featureBitmask'>
  is an unsigned integer encoding the set of feature suites an implementation must support in order to be able to successfully parse the fulfillment to this condition. This is the boolean OR of the featureBitmask values of the top-level condition type and all subcondition types, recursively.</t>
  <t hangText='fingerprint'>
  is an octet string uniquely representing the condition with respect to other conditions of the same type. Implementations which index conditions MUST use the entire string or binary encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint. The length and contents of the fingerprint are defined by the condition type. For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key. This is encoded as a variable length octet string as different condition types may use different functions to produce the fingerprint which may therefore have different lengths. While it would be possible to determine the expected length of the fingerprint based on the type it is useful to be able to decode a condition even if the type is not recognized.</t>
  <t hangText='maxFulfillmentLength'>
  is the maximum length of the fulfillment payload that can fulfill this condition, in bytes. The payload size is measured unencoded. (The size of the payload is larger in BASE64URL format.) When a crypto-condition is submitted to an implementation, this implementation MUST verify that it will be able to process a fulfillment with a payload of size maxFulfillmentLength.</t>
</list></t>

</section>
<section anchor="example-condition" title="Example Condition">

<t>An example condition in string format:</t>

<figure><artwork><![CDATA[
cc:0:3:dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA:66
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cc</spanx></c>
      <c>Constant. Indicates this is a condition.</c>
      <c>type</c>
      <c><spanx style="verb">0</spanx></c>
      <c>Type 0 is [PREIMAGE-SHA-256][].</c>
      <c>featuresBitmask</c>
      <c><spanx style="verb">3</spanx></c>
      <c>Boolean-OR combination of feature suites SHA-256 (feature bit 0x01) and PREIMAGE (feature bit 0x02).</c>
      <c>fingerprint</c>
      <c><spanx style="verb">dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA</spanx></c>
      <c>The hash of the fulfillment for this condition.</c>
      <c>maxFulfillmentLength</c>
      <c><spanx style="verb">66</spanx></c>
      <c>The fulfillment payload is 66 bytes long, before being BASE64URL-encoded.</c>
</texttable>

</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">
<t>Below are the string and binary encoding formats for a fulfillment.</t>

<section anchor="string-fulfillment-format" title="String Format">

<t>Fulfillments are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cf:" BASE16(type) ":" BASE64URL(payload)
]]></artwork></figure>

</section>
<section anchor="binary-fulfillment-format" title="Binary Format">

<t>Fulfillments are binary encoded as:</t>

<figure><artwork><![CDATA[
Fulfillment ::= SEQUENCE {
  type ConditionType,
  payload OCTET STRING
}
]]></artwork></figure>

</section>
<section anchor="fulfillment-format-fields" title="Fields">

<t><list style="hanging">
  <t hangText='type'>
  is the numeric type identifier representing the condition type. For some condition types the fulfillment will contain further subfulfillments, however the type field always represents the outermost, or top-level, type.</t>
  <t hangText='payload'>
  The payload is an octet string whose internal format is defined by each of the types.</t>
</list></t>

</section>
<section anchor="example-fulfillment" title="Example Fulfillment">

<t>The following is an example fulfillment in string format, for the <xref target="example-condition">example condition</xref>:</t>

<figure><artwork><![CDATA[
cf:0:VGhlIG9ubHkgYmFzaXMgZm9yIGdvb2QgU29jaWV0eSBpcyB1bmxpbWl0ZWQgY3JlZGl0LuKAlE9zY2FyIFdpbGRl
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cf</spanx></c>
      <c>Constant. Indicates this is a fulfillment.</c>
      <c>type</c>
      <c><spanx style="verb">0</spanx></c>
      <c>Type 0 is [PREIMAGE-SHA-256][].</c>
      <c>payload</c>
      <c><spanx style="verb">VGhlIG...pbGRl</spanx></c>
      <c>The BASE64URL-encoded SHA-256 preimage of the condition, since this is a PREIMAGE-SHA-256 type fulfillment. In this case, it is an arbitrary string.</c>
</texttable>

</section>
</section>
</section>
<section anchor="feature-suites" title="Feature Suites">
<t>This specification defines a starting set of feature suites necessary to support the [Condition Types][] also defined in this specification. Future versions of this spec MAY introduce new feature suites and condition types, which SHALL be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<t>Support for a condition type MUST depend on one or more feature suites.  However, all new condition types MUST depend on at least one of the new feature suites. This ensures that all previously created implementations correctly recognize that they do not support the new type.</t>

<t>Feature suites are chosen such that they represent reasonable clusters of functionality. For instance, it is reasonable to require that an implementation which supports SHA-256 in one context MUST support it in all contexts, since it already needed to implement the algorithm.</t>

<t>An implementation which supports a certain set of feature suites MUST accept all condition types which depend only on that set or any subset of feature suites.</t>

<texttable>
      <ttcol align='left'>Suite Name</ttcol>
      <ttcol align='left'>Feature Bit</ttcol>
      <ttcol align='left'>Feature Bit (BASE16)</ttcol>
      <ttcol align='left'>Summary</ttcol>
      <c>SHA-256</c>
      <c>2^0</c>
      <c>0x01</c>
      <c>The SHA-256 hashing algorithm.</c>
      <c>PREIMAGE</c>
      <c>2^1</c>
      <c>0x02</c>
      <c>The functionality of comparing a hash to a preimage.</c>
      <c>PREFIX</c>
      <c>2^2</c>
      <c>0x04</c>
      <c>The functionality of prefixing the fulfillment with a prefix before generating the condition.</c>
      <c>THRESHOLD</c>
      <c>2^3</c>
      <c>0x08</c>
      <c>The functionality of composing a condition out of several weighted subconditions.</c>
      <c>RSA-PSS</c>
      <c>2^4</c>
      <c>0x10</c>
      <c>The RSA-PSS signature algorithm.</c>
      <c>ED25519</c>
      <c>2^5</c>
      <c>0x20</c>
      <c>The ED25519 signature algorithm.</c>
</texttable>

<section anchor="sha-256-feature-suite" title="SHA-256">

<t>The SHA-256 feature suite provides the SHA-256 hash function. SHA-256 is a cryptographic hash function published by the US National Institute of Standards and Technology that produces 256 bits of output. This feature suite is assigned the feature bit 2^0 = 0x01.</t>

</section>
<section anchor="preimage-feature-suite" title="PREIMAGE">
<t>The PREIMAGE feature suite provides conditions that use a preimage as a one-time signature. This feature suite is assigned the feature bit 2^1 = 0x02.</t>

<t>The fingerprint of a preimage condition is the hash of an arbitrary value. The payload of a preimage fulfillment is the hashed arbitrary value before hashing, also known as the preimage. Conditions that use this preimage MUST also rely on a cryptographically secure hashing algorithm. Since cryptographically secure hashing functions are preimage-resistant, only the original creator of a preimage condition can produce the preimage, as long as it contains a large amount of random entropy.</t>

</section>
<section anchor="prefix-feature-suite" title="PREFIX">
<t>The PREFIX feature suite provides conditions that prepend a fixed message to a subcondition. This feature suite is assigned the feature bit 2^2 = 0x04.</t>

<t>A prefix condition prepends the message to be validated with a constant string before passing it on to the subcondition's validation function. <!-- TODO: better explanation of why --></t>

</section>
<section anchor="threshold-feature-suite" title="THRESHOLD">
<t>The THRESHOLD feature suite provides conditions that have several weighted subconditions and a threshold number. This feature suite is assigned the feature bit 2^3 = 0x08.</t>

<t>Threshold conditions provide flexible multi-signing, such as requiring "M-of-N" subconditions be fulfilled. Subconditions can also be weighted so that one subcondition can count multiple times towards meeting the threshold.</t>

</section>
<section anchor="rsa-pss-feature-suite" title="RSA-PSS">
<t>The RSA-PSS feature suite provides the RSS-PSA signature algorithm. RSA-PSS is a signature algorithm based on the RSA cryptosystem, which relates to the problem of factoring the product of two large prime numbers. This feature suite is assigned the feature bit 2^4 = 0x10.</t>

</section>
<section anchor="ed25519-feature-suite" title="ED25519">
<t>The ED25519 feature suite provides the Ed25519 signature algorithm. Ed25519 is a signature algorithm based on the EdDSA signing scheme and the compact elliptic curve known as Ed25519. This feature suite is assigned the feature bit 2^5 = 0x20.</t>

</section>
</section>
<section anchor="condition-types" title="Condition Types">
<t>The following condition types are defined in this version of the specification. Future versions of this spec MAY introduce new feature suites and condition types, which SHALL be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">
<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the SHA-256 and PREIMAGE feature suites which corresponds to a feature bitmask of 0x03.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment.</t>

<section anchor="preimage-sha-256-condition-type-condition" title="Condition">
<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment">
<t>The fulfillment payload of a PREIMAGE-SHA-256 condition is the preimage.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<t>Example condition:</t>

<figure><artwork><![CDATA[
cc:0:3:dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA:66
]]></artwork></figure>

<t>Example fulfillment:</t>

<figure><artwork><![CDATA[
cf:0:VGhlIG9ubHkgYmFzaXMgZm9yIGdvb2QgU29jaWV0eSBpcyB1bmxpbWl0ZWQgY3JlZGl0LuKAlE9zY2FyIFdpbGRl
]]></artwork></figure>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the SHA-256 and PREFIX feature suites which corresponds to a feature bitmask of 0x05.</t>

<t>Prefix conditions provide a way to effective narrow the scope of other conditions. A condition can be used as the fingerprint of a public key to sign an arbitrary message. By creating a prefix subcondition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>When a prefix fulfillment is validated against a message, it will prepend the prefix to the provided message and will use the result as the message to validate against the subfulfillment.</t>

<section anchor="prefix-sha-256-condition-type-condition" title="Condition">
<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
PrefixSha256FingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  condition Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='condition'>
  is the subcondition which the subfulfillment must match.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
PrefixSha256FulfillmentPayload ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment Fulfillment
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subfulfillment'>
  is the fulfilled subcondition.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<t>Example condition:</t>

<figure><artwork><![CDATA[
cc:1:25:7myveZs3EaZMMuez-3kq6u69BDNYMYRMi_VF9yIuFLc:102
]]></artwork></figure>

<t>Example fulfillment:</t>

<figure><artwork><![CDATA[
cf:1:DUhlbGxvIFdvcmxkISAABGDsFyuTrV5WO_STLHDhJFA0w1Rn7y79TWTr-BloNGfiv7YikfrZQy-PKYucSkiV2-KT9v_aGmja3wzN719HoMchKl_qPNqXo_TAPqny6Kwc7IalHUUhJ6vboJ0bbzMcBwo
]]></artwork></figure>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the SHA-256 and THRESHOLD feature suites which corresponds to a feature bitmask of 0x09.</t>

<section anchor="threshold-sha-256-condition-type-condition" title="Condition">
<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (0..4294967295),
  subconditions SEQUENCE OF ThresholdSubcondition
}

ThresholdSubcondition ::= SEQUENCE {
  weight INTEGER (0..4294967295),
  condition Condition
}
]]></artwork></figure>

<t>The list of conditions is sorted first based on length, shortest first. Elements of the same length are sorted in lexicographic (big-endian) order, smallest first.</t>

<t><list style="hanging">
  <t hangText='threshold'>
  threshold MUST be an integer in the range 1 … 2^32 - 1. In order to fulfill a threshold condition, the weights of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subconditions'>
  is the set of subconditions, each provided as a tuple of weight and condition.</t>
  <t hangText='weight'>
  is the numeric weight of this subcondition, i.e. how many times it counts against the threshold.</t>
  <t hangText='condition'>
  is the subcondition.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
ThresholdSha256FulfillmentPayload ::= SEQUENCE {
  threshold INTEGER (0..4294967295),
  subfulfillments SEQUENCE OF ThresholdSubfulfillment
}

ThresholdSubfulfillment ::= SEQUENCE {
  weight INTEGER (0..4294967295) DEFAULT 1,
  condition Condition OPTIONAL,
  fulfillment Fulfillment OPTIONAL
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='threshold'>
  is a number and MUST be an integer in the range 1 … 2^32 - 1. In order to fulfill a threshold condition, the weights of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subfulfillments'>
  is the set of subconditions and subfulfillments, each provided as a tuple of weight and condition or fulfillment.</t>
  <t hangText='weight'>
  is the numeric weight of this subcondition, i.e. how many times it counts against the threshold. It MUST be an integer in the range 1 … 2^32 - 1.</t>
  <t hangText='condition'>
  is the subcondition if this subcondition is not fulfilled.</t>
  <t hangText='fulfillment'>
  is the subfulfillment if this subcondition is fulfilled.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<t>Example condition:</t>

<figure><artwork><![CDATA[
cc:2:2b:mJUaGKCuF5n-3tfXM2U81VYtHbX-N8MP6kz8R-ASwNQ:146
]]></artwork></figure>

<t>Example fulfillment:</t>

<figure><artwork><![CDATA[
cf:2:AQEBAgEBAwAAAAABAQAnAAQBICDsFyuTrV5WO_STLHDhJFA0w1Rn7y79TWTr-BloNGfivwFg
]]></artwork></figure>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256 and RSA-PSS feature suites which corresponds to a feature bitmask of 0x11.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC3447"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefor, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC3447"></xref>. Implementations MUST also use a salt length of 32 bytes (equal to the size of the output from the SHA-256 algorithm). Therefore the algorithm identifier will have the following value:</t>

<figure><artwork><![CDATA[
rSASSA-PSS-Crypto-Conditions-Identifier  RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS,
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha256,
        maskGenAlgorithm    mgf1SHA256,
        saltLength          32,
        trailerField        trailerFieldBC
    }
}
   
sha256 HashAlgorithm ::= {
    algorithm   id-sha256,
    parameters  NULL
}

mgf1SHA256 MaskGenAlgorithm ::= {
    algorithm   id-mgf1,
    parameters  HashAlgorithm : sha256
}
]]></artwork></figure>

<section anchor="rsa-sha-256-condition-type-condition" title="Condition">
<t>The fingerprint of a RSA-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
RsaSha256FingerprintContents ::= SEQUENCE {
  modulus OCTET STRING (SIZE(128..512))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  is an octet string representing the RSA public modulus in big-endian byte order. The first byte of the modulus MUST NOT be zero.</t>
  <t>The corresponding public exponent e is assumed to be 65537 as recommended in <xref target="RFC4871"></xref> . Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref> .</t>
  <t>Implementations MUST reject moduli smaller than 128 bytes (1017 bits) or greater than 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref> . OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref> .</t>
</list></t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
RsaSha256FulfillmentPayload ::= SEQUENCE {
  modulus OCTET STRING (SIZE(128..512)),
  signature OCTET STRING (SIZE(128..512))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  is an octet string representing the RSA public modulus in big-endian byte order. See <xref target="rsa-sha-256-condition-type-condition"></xref></t>
  <t hangText='signature'>
  is an octet string representing the RSA signature. It MUST be encoded in big-endian byte order with the exact same number of octets as the modulus, even if this means adding leading zeros. This ensures that the fulfillment size is constant and known ahead of time. Note that the field is still binary encoded with a length prefix for consistency.</t>
  <t>Implementations MUST verify that the signature and modulus consist of the same number of octets and that the signature is numerically less than the modulus.</t>
</list></t>

<t>The message to be signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-implementation" title="Implementation">
<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref> . In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<t>Example condition:</t>

<figure><artwork><![CDATA[
cc:3:11:Bw-r77AGqSCL0huuMQYj3KW0Jh67Fpayeq9h_4UJctg:260
]]></artwork></figure>

<t>Example fulfillment:</t>

<figure><artwork><![CDATA[
cf:3:gYCzDnqTh4O6v4NoUP9J4U-H4_ktXEbjP-yj5PCyI1hYCxF2WZX0uO6n-0cSwuHjFvf3dalT0jIhahadmmTdwAcSCkALN_KvwHe2L-ME3nTeahGexAdrUpxPYJawuq1PUz3wFzubgi_YXWX6S--pLY9ST2nLygE2vYDQlcFprsDglYGAjQM0-Z5B-953uQtJ5dXL1D5TWpM0s0eFF0Zty7J2Y3Nb0PqsR5I47a2wYlA7-106vjC8gHFdHVeSR6JksSrhj8YaMWfV0A6qhPz6hq-TqSKCXd4mf3eCpyyFYR_EyH5zXd56sJEU3snWlFbB_bKAW4si_qdfY9dT87YGUp_Grm0
]]></artwork></figure>

</section>
</section>
<section anchor="ed25519-condition-type" title="ED25519">
<t>ED25519 is assigned the type ID 4. It relies only on the ED25519 feature suite which corresponds to a bitmask of 0x20.</t>

<t>The exact algorithm and encodings used for public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function.</t>

<t>Note: This document is not defining the SHA-512 versions of other condition types. In addition, the Ed25519 condition type is already uniquely identified by a corresponding Ed25519 feature suite. Therefore we intentionally do not introduce a SHA-512 feature suite in this document.</t>

<section anchor="ed25519-condition-type-condition" title="Condition">
<t>The fingerprint of a ED25519 condition is the 32 byte Ed25519 public key. Since the public key is already very small, we do not hash it.</t>

</section>
<section anchor="ed25519-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
Ed25519FulfillmentPayload ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='publicKey'>
  is an octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  is an octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="example" title="Example">

<t>Example condition:</t>

<figure><artwork><![CDATA[
cc:4:20:7Bcrk61eVjv0kyxw4SRQNMNUZ-8u_U1k6_gZaDRn4r8:96
]]></artwork></figure>

<t>Example fulfillment:</t>

<figure><artwork><![CDATA[
cf:4:7Bcrk61eVjv0kyxw4SRQNMNUZ-8u_U1k6_gZaDRn4r-2IpH62UMvjymLnEpIldvik_b_2hpo2t8Mze9fR6DHISpf6jzal6P0wD6p8uisHOyGpR1FISer26CdG28zHAcK
]]></artwork></figure>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3447;
&RFC4648;
&I-D.draft-irtf-cfrg-eddsa-04;
<reference anchor="itu.X680.2015" target="https://www.itu.int/rec/T-REC-X.680-201508-I/">
  <front>
    <title>Information technology – Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X696.2015" target="http://handle.itu.int/11.1002/1000/12487">
  <front>
    <title>Information technology – ASN.1 encoding rules: Specification of Octet Encoding Rules (OER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This section to be expanded in a later draft. <!-- TODO --></t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --> For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--

CryptoConditions
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

/**
* CONTAINERS
*/

Condition ::= SEQUENCE {
type ConditionType,
featureBitmask OCTET STRING,
fingerprint OCTET STRING,
maxFulfillmentLength INTEGER (0..MAX)
}

Fulfillment ::= SEQUENCE {
type ConditionType,
payload OCTET STRING
}

ConditionType ::= INTEGER {
preimageSha256(0),
rsaSha256(1),
prefixSha256(2),
thresholdSha256(3),
ed25519(4)
} (0..65535)

/**
* FULFILLMENT PAYLOADS
*/

-- For preimage conditions, the payload equals the preimage

PrefixSha256FulfillmentPayload ::= SEQUENCE {
prefix OCTET STRING,
subfulfillment Fulfillment
}

ThresholdSha256FulfillmentPayload ::= SEQUENCE {
threshold INTEGER (0..4294967295),
subfulfillments SEQUENCE OF ThresholdSubfulfillment
}

ThresholdSubfulfillment ::= SEQUENCE {
weight INTEGER (0..4294967295) DEFAULT 1,
condition Condition OPTIONAL,
fulfillment Fulfillment OPTIONAL
}

RsaSha256FulfillmentPayload ::= SEQUENCE {
modulus OCTET STRING (SIZE(128..512)),
signature OCTET STRING (SIZE(128..512))
}

Ed25519FulfillmentPayload ::= SEQUENCE {
publicKey OCTET STRING (SIZE(32)),
signature OCTET STRING (SIZE(64))
}

/**
* FINGERPRINTS
*/

-- SHA-256 hash of the fingerprint contents
Sha256Fingerprint ::= OCTET STRING (SIZE(32)) -- digest

-- 32-byte Ed25519 public key
Ed25519Fingerprint ::= OCTET STRING (SIZE(32)) -- publicKey

/**
* FINGERPRINT CONTENTS
*
* The content that will be hashed to arrive at the fingerprint.
*/

-- The preimage type hashes the raw contents of the preimage

PrefixSha256FingerprintContents ::= SEQUENCE {
prefix OCTET STRING,
condition Condition
}

ThresholdSha256FingerprintContents ::= SEQUENCE {
threshold INTEGER (0..4294967295),
subconditions SEQUENCE OF ThresholdSubcondition
}

ThresholdSubcondition ::= SEQUENCE {
weight INTEGER (0..4294967295),
condition Condition
}

RsaSha256FingerprintContents ::= INTEGER (0..MAX) -- modulus

/**
* EXAMPLES
*/

exampleCondition Condition ::=
{
type preimageSha256,
featureBitmask '03'H,
fingerprint '
E3B0C442 98FC1C14 9AFBF4C8 996FB924 27AE41E4 649B934C A495991B 7852B855
'H,
maxFulfillmentLength 2
}

exampleFulfillment Fulfillment ::=
{
type preimageSha256,
payload '00'H
}

exampleRsaSha256FulfillmentPayload RsaSha256FulfillmentPayload ::=
{
modulus '
B30E7A93 8783BABF 836850FF 49E14F87 E3F92D5C 46E33FEC A3E4F0B2 2358580B
11765995 F4B8EEA7 FB4712C2 E1E316F7 F775A953 D232216A 169D9A64 DDC00712
0A400B37 F2AFC077 B62FE304 DE74DE6A 119EC407 6B529C4F 6096B0BA AD4F533D
F0173B9B 822FD85D 65FA4BEF A92D8F52 4F69CBCA 0136BD80 D095C169 AEC0E095
'H,
signature '
48E8945E FE007556 D5BF4D5F 249E4808 F7307E29 511D3262 DAEF61D8 8098F9AA
4A8BC062 3A8C9757 38F65D6B F459D543 F289D73C BC7AF4EA 3A33FBF3 EC444044
7911D722 94091E56 1833628E 49A772ED 608DE6C4 4595A91E 3E17D6CF 5EC3B252
8D63D2AD D6463989 B12EEC57 7DF64709 60DF6832 A9D84C36 0D1C217A D64C8625
BDB594FB 0ADA086C DECBBDE5 80D424BF 9746D2F0 C312826D BBB00AD6 8B52C4CB
7D47156B A35E3A98 1C973863 792CC80D 04A18021 0A524158 65B64B3A 61774B1D
3975D78A 98B0821E E55CA0F8 6305D425 29E10EB0 15CEFD40 2FB59B2A BB8DEEE5
2A6F2447 D2284603 D219CD4E 8CF9CFFD D5498889 C3780B59 DD6A57EF 7D732620
'H
}

exampleEd25519FulfillmentPayload Ed25519FulfillmentPayload ::=
{
publicKey '
EC172B93 AD5E563B F4932C70 E1245034 C35467EF 2EFD4D64 EBF81968 3467E2BF
'H,
signature '
B62291FA D9432F8F 298B9C4A 4895DBE2 93F6FFDA 1A68DADF 0CCDEF5F 47A0C721
2A5FEA3C DA97A3F4 C03EA9F2 E8AC1CEC 86A51D45 2127ABDB A09D1B6F 331C070A
'H
}

END
]]></artwork></figure>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following feature suite bits are registered:</t>

<texttable title="Crypto-Condition Feature Suites" anchor="crypto-condition-feature-suites">
      <ttcol align='left'>Type Bit</ttcol>
      <ttcol align='left'>Exp.</ttcol>
      <ttcol align='left'>Hex</ttcol>
      <ttcol align='left'>Feature</ttcol>
      <c>1</c>
      <c>2^0</c>
      <c>0x01</c>
      <c>SHA-256</c>
      <c>10</c>
      <c>2^1</c>
      <c>0x02</c>
      <c>PREIMAGE</c>
      <c>100</c>
      <c>2^2</c>
      <c>0x04</c>
      <c>PREFIX</c>
      <c>1000</c>
      <c>2^3</c>
      <c>0x08</c>
      <c>THRESHOLD</c>
      <c>10000</c>
      <c>2^4</c>
      <c>0x10</c>
      <c>RSA</c>
      <c>100000</c>
      <c>2^5</c>
      <c>0x20</c>
      <c>ED25519</c>
</texttable>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Required Bitmask</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>0x03</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>0x05</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>0x09</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>0x11</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>0x20</c>
      <c>ED25519</c>
</texttable>

</section>
</section>


  </back>
</rfc>

